Index: buildings.cpp
===================================================================
--- buildings.cpp	(revision 3442)
+++ buildings.cpp	(working copy)
@@ -277,7 +277,6 @@
 //--------------------------------------------------------------------------
 void cBuilding::draw (SDL_Rect* screenPos, cGameGUI& gameGUI)
 {
-	SDL_Rect dest, tmp;
 	float factor = (float) gameGUI.getTileSize() / 64.0f;
 	cPlayer* activePlayer = gameGUI.getClient()->getActivePlayer();
 	// draw the damage effects
@@ -296,7 +295,7 @@
 		}
 	}
 
-	dest.x = dest.y = 0;
+	SDL_Rect dest = {0, 0, 0, 0};
 	bool bDraw = false;
 	SDL_Surface* drawingSurface = gameGUI.getDCache()->getCachedImage (*this);
 	if (drawingSurface == NULL)
@@ -342,8 +341,8 @@
 	// draw the effect if necessary
 	if (data.powerOnGraphic && cSettings::getInstance().isAnimations() && (IsWorking || !data.canWork))
 	{
-		tmp = dest;
-		SDL_SetAlpha (uiData->eff, SDL_SRCALPHA, EffectAlpha);
+		SDL_Rect tmp = dest;
+		SDL_SetSurfaceAlphaMod (uiData->eff, EffectAlpha);
 
 		CHECK_SCALING (uiData->eff, uiData->eff_org, factor);
 		SDL_BlitSurface (uiData->eff, NULL, buffer, &tmp);
@@ -356,7 +355,7 @@
 
 				if (EffectAlpha > 220)
 				{
-					EffectAlpha = 255;
+					EffectAlpha = 254;
 					EffectInc = false;
 				}
 			}
@@ -376,7 +375,7 @@
 	// draw the mark, when a build order is finished
 	if ( ( (!BuildList.empty() && !IsWorking && BuildList[0].metall_remaining <= 0) || (data.canResearch && owner->researchFinished)) && owner == gameGUI.getClient()->getActivePlayer())
 	{
-		const Uint32 color = 0xFF00 - (0x1000 * (gameGUI.getAnimationSpeed() % 0x8));
+		const Uint32 color = 0xFF00FF00 - (0x1000 * (gameGUI.getAnimationSpeed() % 0x8));
 		const Uint16 max = data.isBig ? 2 * gameGUI.getTileSize() - 3 : gameGUI.getTileSize() - 3;
 		SDL_Rect d = {Sint16 (dest.x + 2), Sint16 (dest.y + 2), max, max};
 
@@ -392,7 +391,7 @@
 	// draw a colored frame if necessary
 	if (gameGUI.colorChecked())
 	{
-		const Uint32 color = *static_cast<Uint32*> (owner->getColorSurface()->pixels);
+		const Uint32 color = 0xFF000000 | *static_cast<Uint32*> (owner->getColorSurface()->pixels);
 		const Uint16 max = data.isBig ? 2 * gameGUI.getTileSize() - 1 : gameGUI.getTileSize() - 1;
 		SDL_Rect d = {Sint16 (dest.x + 1), Sint16 (dest.y + 1), max, max};
 
@@ -406,7 +405,7 @@
 		const int len = max / 4;
 		max -= 3;
 		SDL_Rect d = {Sint16 (dest.x + 2), Sint16 (dest.y + 2), max, max};
-		DrawSelectionCorner(buffer, d, len, gameGUI.getBlinkColor());
+		DrawSelectionCorner(buffer, d, len, 0xFF000000 | gameGUI.getBlinkColor());
 	}
 
 	// draw health bar
@@ -493,9 +492,9 @@
 		CHECK_SCALING (GraphicsData.gfx_big_beton, GraphicsData.gfx_big_beton_org, zoomFactor);
 
 		if (StartUp && cSettings::getInstance().isAlphaEffects())
-			SDL_SetAlpha (GraphicsData.gfx_big_beton, SDL_SRCALPHA, StartUp);
+			SDL_SetSurfaceAlphaMod (GraphicsData.gfx_big_beton, StartUp);
 		else
-			SDL_SetAlpha (GraphicsData.gfx_big_beton, SDL_SRCALPHA, 255);
+			SDL_SetSurfaceAlphaMod (GraphicsData.gfx_big_beton, 254);
 
 		SDL_BlitSurface (GraphicsData.gfx_big_beton, NULL, surface, &tmp);
 	}
@@ -503,12 +502,12 @@
 	{
 		CHECK_SCALING (UnitsData.ptr_small_beton, UnitsData.ptr_small_beton_org, zoomFactor);
 		if (StartUp && cSettings::getInstance().isAlphaEffects())
-			SDL_SetAlpha (UnitsData.ptr_small_beton, SDL_SRCALPHA, StartUp);
+			SDL_SetSurfaceAlphaMod (UnitsData.ptr_small_beton, StartUp);
 		else
-			SDL_SetAlpha (UnitsData.ptr_small_beton, SDL_SRCALPHA, 255);
+			SDL_SetSurfaceAlphaMod (UnitsData.ptr_small_beton, 254);
 
 		SDL_BlitSurface (UnitsData.ptr_small_beton, NULL, surface, &tmp);
-		SDL_SetAlpha (UnitsData.ptr_small_beton, SDL_SRCALPHA, 255);
+		SDL_SetSurfaceAlphaMod (UnitsData.ptr_small_beton, 254);
 	}
 }
 
@@ -531,7 +530,7 @@
 
 	// blit the players color and building graphic
 	if (data.hasPlayerColor) SDL_BlitSurface (owner->getColorSurface(), NULL, GraphicsData.gfx_tmp, NULL);
-	else SDL_FillRect (GraphicsData.gfx_tmp, NULL, 0x00FF00FF);
+	else SDL_FillRect (GraphicsData.gfx_tmp, NULL, 0xFFFF00FF);
 
 	if (data.hasFrames)
 	{
@@ -566,7 +565,7 @@
 	src.x = 0;
 	src.y = 0;
 
-	SDL_SetAlpha (GraphicsData.gfx_tmp, SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_tmp, alpha);
 	SDL_BlitSurface (GraphicsData.gfx_tmp, &src, surface, &tmp);
 }
 
@@ -588,7 +587,6 @@
 	{
 		render_beton (surface, dest, zoomFactor);
 	}
-
 	// draw the connector slots:
 	if ( (this->SubBase && !StartUp) || data.isConnectorGraphic)
 	{
@@ -601,9 +599,9 @@
 	{
 		SDL_Rect tmp = dest;
 		if (StartUp && cSettings::getInstance().isAlphaEffects())
-			SDL_SetAlpha (uiData->shw, SDL_SRCALPHA, StartUp / 5);
+			SDL_SetSurfaceAlphaMod (uiData->shw, StartUp / 5);
 		else
-			SDL_SetAlpha (uiData->shw, SDL_SRCALPHA, 50);
+			SDL_SetSurfaceAlphaMod (uiData->shw, 50);
 
 		CHECK_SCALING (uiData->shw, uiData->shw_org, zoomFactor);
 		blittAlphaSurface (uiData->shw, NULL, surface, &tmp);
@@ -616,7 +614,7 @@
 		frameNr = (gameGUI->getAnimationSpeed() % data.hasFrames);
 	}
 
-	int alpha = 255;
+	int alpha = 254;
 	if (StartUp && cSettings::getInstance().isAlphaEffects()) alpha = StartUp;
 	render_simple (surface, dest, zoomFactor, frameNr, alpha);
 }
@@ -668,7 +666,6 @@
 	}
 	else
 	{
-
 		CHECK_NEIGHBOUR (PosX    , PosY - 1, BaseN)
 		CHECK_NEIGHBOUR (PosX + 1, PosY - 1, BaseBN)
 		CHECK_NEIGHBOUR (PosX + 2, PosY    , BaseE)
@@ -690,8 +687,8 @@
 	CHECK_SCALING (UnitsData.ptr_connector, UnitsData.ptr_connector_org, zoomFactor);
 	CHECK_SCALING (UnitsData.ptr_connector_shw, UnitsData.ptr_connector_shw_org, zoomFactor);
 
-	if (StartUp) SDL_SetAlpha (UnitsData.ptr_connector, SDL_SRCALPHA, StartUp);
-	else SDL_SetAlpha (UnitsData.ptr_connector, SDL_SRCALPHA, 255);
+	if (StartUp) SDL_SetSurfaceAlphaMod (UnitsData.ptr_connector, StartUp);
+	else SDL_SetSurfaceAlphaMod (UnitsData.ptr_connector, 254);
 
 	src.y = 0;
 	src.x = 0;
@@ -1346,6 +1343,7 @@
 	dest.x = x;
 	dest.y = y;
 
+	Uint32 color = SDL_MapRGB (sf->format, 0xFC, 0, 0);
 	for (int i = 0; i < value; i++)
 	{
 		if (i == orgvalue)
@@ -1356,7 +1354,7 @@
 			mark.y = dest.y;
 			mark.w = 1;
 			mark.h = src.h;
-			SDL_FillRect (sf, &mark, 0xFC0000);
+			SDL_FillRect (sf, &mark, color);
 		}
 
 		SDL_BlitSurface (GraphicsData.gfx_hud_stuff, &src, sf, &dest);
Index: buildings.h
===================================================================
--- buildings.h	(revision 3442)
+++ buildings.h	(working copy)
@@ -220,7 +220,7 @@
 	* draws the main image of the building onto the given surface
 	*/
 	void render (const cGameGUI* gameGUI, SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, bool drawShadow, bool drawConcrete);
-	void render_simple (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int frameNr, int alpha = 255);
+	void render_simple (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int frameNr, int alpha = 254);
 
 	void executeUpdateBuildingCommmand (const cClient& client, bool updateAllOfSameType);
 	void executeSelfDestroyCommand (cClient& client);
Index: client.cpp
===================================================================
--- client.cpp	(revision 3442)
+++ client.cpp	(working copy)
@@ -2005,7 +2005,7 @@
 #endif
 	// reset the screen
 	gameGUI->deselectUnit();
-	SDL_Surface* sf = SDL_CreateRGBSurface (SDL_SRCCOLORKEY, Video.getResolutionX(), Video.getResolutionY(), 32, 0, 0, 0, 0);
+	SDL_Surface* sf = SDL_CreateRGBSurface (0, Video.getResolutionX(), Video.getResolutionY(), 32, 0, 0, 0, 0);
 	SDL_Rect scr = { 15, 356, 112u, 112u};
 	SDL_BlitSurface (sf, NULL, buffer, NULL);
 	SDL_BlitSurface (sf, &scr, buffer, &scr);
Index: defines.h
===================================================================
--- defines.h	(revision 3446)
+++ defines.h	(working copy)
@@ -20,12 +20,12 @@
 #define definesH
 #include "settings.h"
 
-#define GRID_COLOR         0x00305C04 // color of the grid
-#define SCAN_COLOR         0x00E3E300 // color of scan circles
-#define RANGE_GROUND_COLOR 0x00E20000 // color of range circles for ground attack
-#define RANGE_AIR_COLOR    0x00FCA800 // color of range circles for air attack
-#define PFEIL_COLOR        0x000000FF // color of a waypointarrow
-#define PFEILS_COLOR       0x0000FF00 // color of a special waypointarrow
+#define GRID_COLOR         0xFF305C04 // color of the grid
+#define SCAN_COLOR         0xFFE3E300 // color of scan circles
+#define RANGE_GROUND_COLOR 0xFFE20000 // color of range circles for ground attack
+#define RANGE_AIR_COLOR    0xFFFCA800 // color of range circles for air attack
+#define PFEIL_COLOR        0xFF0000FF // color of a waypointarrow
+#define PFEILS_COLOR       0xFF00FF00 // color of a special waypointarrow
 #define MOVE_SPEED 2     // speed of vehiclemovements
 #define MSG_TICKS  30000 // number of ticks for how long a message will be displayed
 #define LANDING_DISTANCE_WARNING   28
@@ -33,7 +33,7 @@
 #define MAX_PLANES_PER_FIELD 5
 
 // minimap configuration
-#define MINIMAP_COLOR 0x00FC0000 // color of the screen borders on the minimap
+#define MINIMAP_COLOR 0xFFFC0000 // color of the screen borders on the minimap
 #define MINIMAP_POS_X 15         // the position of the map on the screen
 #define MINIMAP_POS_Y 356        // the position of the map on the screen
 #define MINIMAP_SIZE  112        // the size of the minimap in pixels
Index: dialog.cpp
===================================================================
--- dialog.cpp	(revision 3442)
+++ dialog.cpp	(working copy)
@@ -71,7 +71,7 @@
 	menuItems.push_back (&noButton);
 }
 
-void cDialogYesNo::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cDialogYesNo::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	switch (key.keysym.sym)
 	{
@@ -106,7 +106,7 @@
 	menuItems.push_back (&okButton);
 }
 
-void cDialogOK::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cDialogOK::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	if (key.keysym.sym == SDLK_RETURN)
 	{
@@ -248,7 +248,7 @@
 	draw();
 }
 
-void cDialogLicence::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cDialogLicence::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	if (key.keysym.sym == SDLK_RETURN)
 	{
@@ -632,13 +632,13 @@
 {
 	const int UNIT_IMAGE_SIZE = 64;
 
-	SDL_Surface* unitImage1 = SDL_CreateRGBSurface (SDL_SRCCOLORKEY, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_Surface* unitImage1 = SDL_CreateRGBSurface (0, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
 	SDL_FillRect (unitImage1, NULL, 0xFF00FF);
-	SDL_SetColorKey (unitImage1, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetColorKey (unitImage1, SDL_TRUE, 0xFF00FF);
 
-	SDL_Surface* unitImage2 = SDL_CreateRGBSurface (SDL_SRCCOLORKEY, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_Surface* unitImage2 = SDL_CreateRGBSurface (0, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
 	SDL_FillRect (unitImage2, NULL, 0xFF00FF);
-	SDL_SetColorKey (unitImage2, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetColorKey (unitImage2, SDL_TRUE, 0xFF00FF);
 
 	SDL_Rect dest = {0, 0, 0, 0};
 
@@ -777,7 +777,7 @@
 		// little hack: flip part of the image that represent the arrow
 		const unsigned int w = 40;
 		const unsigned int h = 20;
-		SDL_Surface* arrowSurface = SDL_CreateRGBSurface (Video.getSurfaceType(), w, h, Video.getColDepth(), 0, 0, 0, 0);
+		SDL_Surface* arrowSurface = SDL_CreateRGBSurface (0, w, h, Video.getColDepth(), 0, 0, 0, 0);
 		const Sint16 x = arrowImage.getPosition().x - position.x; // 140
 		const Sint16 y = arrowImage.getPosition().y - position.y; //  77
 		SDL_Rect src = {x, y, w, h};
@@ -791,7 +791,7 @@
 	resBar->setCurrentValue ( (int) (223.f * (destCargo + transferValue) / maxDestCargo));
 }
 
-void cDialogTransfer::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cDialogTransfer::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	switch (key.keysym.sym)
 	{
@@ -994,7 +994,7 @@
 	}
 }
 
-void cDialogResearch::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cDialogResearch::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	switch (key.keysym.sym)
 	{
Index: dialog.h
===================================================================
--- dialog.h	(revision 3442)
+++ dialog.h	(working copy)
@@ -32,7 +32,7 @@
 	explicit cDialogYesNo (const std::string& text);
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 
 private:
 	cMenuLabel textLabel;
@@ -49,7 +49,7 @@
 	explicit cDialogOK (const std::string& text);
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 
 private:
 	cMenuLabel textLabel;
@@ -80,7 +80,7 @@
 	cDialogLicence();
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 
 private:
 	static void upReleased (void* parent);
@@ -201,7 +201,7 @@
 	~cDialogTransfer();
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 	virtual void handleDestroyUnit (cUnit& destroyedUnit);
 
 private:
@@ -244,7 +244,7 @@
 	explicit cDialogResearch (cClient& client_);
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 	virtual void handleDestroyUnit (cUnit& destroyedUnit);
 
 private:
Index: drawingcache.cpp
===================================================================
--- drawingcache.cpp	(revision 3442)
+++ drawingcache.cpp	(working copy)
@@ -77,10 +77,10 @@
 		width  = 130;
 		height = 130;
 	}
-	surface = SDL_CreateRGBSurface (SDL_SWSURFACE, width, height, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	surface = SDL_CreateRGBSurface (0, width, height, 32,
+									0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
 
-	SDL_FillRect (surface, NULL, SDL_MapRGBA (surface->format, 255, 0, 255, 0));
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGBA (surface->format, 255, 0, 255, 0));
+	SDL_FillRect (surface, NULL, SDL_MapRGBA (surface->format, 0, 0, 0, 0));
 }
 
 void sDrawingCacheEntry::init (const cGameGUI& gameGUI, const cBuilding& building)
@@ -106,10 +106,10 @@
 	int width  = (int) std::max (building.uiData->img_org->w * zoom, building.uiData->shw_org->w * zoom);
 	if (building.data.hasFrames) width = (int) (building.uiData->shw_org->w * zoom);
 
-	surface = SDL_CreateRGBSurface (SDL_SWSURFACE, width, height, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	surface = SDL_CreateRGBSurface (0, width, height, 32,
+									0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
 
-	SDL_FillRect (surface, NULL, SDL_MapRGBA (surface->format, 255, 0, 255, 0));
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY | SDL_RLEACCEL, SDL_MapRGBA (surface->format, 255, 0, 255, 0));
+	SDL_FillRect (surface, NULL, SDL_MapRGBA (surface->format, 0, 0, 0, 0));
 }
 
 cDrawingCache::cDrawingCache()
@@ -346,7 +346,7 @@
 		return false;
 	}
 
-	if (vehicle.IsBuilding && vehicle.data.isBig && vehicle.BigBetonAlpha < 255)
+	if (vehicle.IsBuilding && vehicle.data.isBig && vehicle.BigBetonAlpha < 254u)
 	{
 		notCached++;
 		return false;
Index: events.cpp
===================================================================
--- events.cpp	(revision 3442)
+++ events.cpp	(working copy)
@@ -60,17 +60,6 @@
 	return screenshotfile;
 }
 
-static void HandleInputEvent_SDL_ACTIVEEVENT (SDL_Event& event)
-{
-	assert (event.type == SDL_ACTIVEEVENT);
-#if 1
-	// This is an workaround for a SDL bug.
-	// See Ticket #86 on bugtracker.
-	// will hopefully not be required anymore in SDL 1.3
-	if (event.active.state & SDL_APPINPUTFOCUS) SDL_SetModState (KMOD_NONE);
-#endif
-}
-
 static void HandleInputEvent_KEY (cMenu& activeMenu, SDL_Event& event, cClient* client)
 {
 	assert (event.type == SDL_KEYDOWN || event.type == SDL_KEYUP);
@@ -96,12 +85,14 @@
 {
 	switch (event.type)
 	{
-		case SDL_ACTIVEEVENT: HandleInputEvent_SDL_ACTIVEEVENT (event); break;
 		case SDL_KEYDOWN:
 		case SDL_KEYUP: HandleInputEvent_KEY (activeMenu, event, client); break;
 		case SDL_MOUSEBUTTONDOWN:
 		case SDL_MOUSEBUTTONUP: InputHandler->inputMouseButton (activeMenu, event.button); break;
+		case SDL_MOUSEWHEEL: InputHandler->inputMouseButton (activeMenu, event.wheel); break;
 		case SDL_QUIT: Quit(); break;
+		case SDL_MOUSEMOTION: break;
+		case SDL_WINDOWEVENT: Video.draw(); break;
 		default: break;
 	}
 }
Index: fxeffects.cpp
===================================================================
--- fxeffects.cpp	(revision 3442)
+++ fxeffects.cpp	(working copy)
@@ -293,7 +293,7 @@
 	CHECK_SCALING (images[1], images[0], gameGUI.getZoom());
 
 	const int alpha = (alphaEnd - alphaStart) * tick / length + alphaStart;
-	SDL_SetAlpha (images[1], SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (images[1], alpha);
 
 	SDL_Rect dest;
 	dest = gameGUI.calcScreenPos (posX - images[0]->w / 2, posY - images[0]->h / 2);
@@ -338,7 +338,7 @@
 	CHECK_SCALING (images[1], images[0], gameGUI.getZoom());
 
 	const int alpha = (alphaEnd - alphaStart) * tick / length + alphaStart;
-	SDL_SetAlpha (images[1], SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (images[1], alpha);
 
 	SDL_Rect src, dest;
 	src.y = 0;
@@ -473,6 +473,6 @@
 	dest = gameGUI.calcScreenPos ( (int) (posX + tick * dx), (int) (posY + tick * dy));
 
 	const int alpha = (alphaEnd - alphaStart) * tick / length + alphaStart;
-	SDL_SetAlpha (images[1], SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (images[1], alpha);
 	SDL_BlitSurface (images[1], &src, buffer, &dest);
 }
Index: hud.cpp
===================================================================
--- hud.cpp	(revision 3442)
+++ hud.cpp	(working copy)
@@ -151,7 +151,7 @@
 				string sTmpLine = " " + playerList[i]->getName() + ", nr: " + iToStr (playerList[i]->getNr()) + " << you! ";
 				// black out background for better recognizing
 				rBlackOut.w = font->getTextWide (sTmpLine, FONT_LATIN_SMALL_WHITE);
-				SDL_FillRect (buffer, &rBlackOut, 0x00000000);
+				SDL_FillRect (buffer, &rBlackOut, 0xFF000000);
 				font->showText (rBlackOut.x, debugOff + 1, sTmpLine, FONT_LATIN_SMALL_WHITE);
 			}
 			else
@@ -159,7 +159,7 @@
 				string sTmpLine = " " + playerList[i]->getName() + ", nr: " + iToStr (playerList[i]->getNr()) + " ";
 				// black out background for better recognizing
 				rBlackOut.w = font->getTextWide (sTmpLine, FONT_LATIN_SMALL_WHITE);
-				SDL_FillRect (buffer, &rBlackOut, 0x00000000);
+				SDL_FillRect (buffer, &rBlackOut, 0xFF000000);
 				font->showText (rBlackOut.x, debugOff + 1, sTmpLine, FONT_LATIN_SMALL_WHITE);
 			}
 			// use 10 for pixel high of dots instead of text high
@@ -823,8 +823,6 @@
 
 int cGameGUI::show (cClient* client)
 {
-	drawnEveryFrame = true;
-
 	// do startup actions
 	openPanel();
 	startup = true;
@@ -838,7 +836,7 @@
 		cEventHandling::handleInputEvents (*this, client);
 		client->gameTimer.run (this);
 
-		mouse->GetPos();
+		mouse->updatePos();
 		if (mouse->moved())
 		{
 			handleMouseMove();
@@ -1021,10 +1019,10 @@
 
 SDL_Surface* cGameGUI::generateSurface()
 {
-	SDL_Surface* surface = SDL_CreateRGBSurface (SDL_HWSURFACE, Video.getResolutionX(), Video.getResolutionY(), Video.getColDepth(), 0, 0, 0, 0);
+	SDL_Surface* surface = SDL_CreateRGBSurface (0, Video.getResolutionX(), Video.getResolutionY(), Video.getColDepth(), 0, 0, 0, 0);
 
 	SDL_FillRect (surface, NULL, 0x00FF00FF);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0x00FF00FF);
+	SDL_SetColorKey (surface, SDL_TRUE, 0x00FF00FF);
 
 	const std::string gfxPath = cSettings::getInstance().getGfxPath() + PATH_DELIMITER;
 	{
@@ -1260,7 +1258,7 @@
 
 SDL_Surface* cGameGUI::generateMiniMapSurface()
 {
-	SDL_Surface* minimapSurface = SDL_CreateRGBSurface (SDL_SWSURFACE, MINIMAP_SIZE, MINIMAP_SIZE, 32, 0, 0, 0, 0);
+	SDL_Surface* minimapSurface = SDL_CreateRGBSurface (0, MINIMAP_SIZE, MINIMAP_SIZE, 32, 0, 0, 0, 0);
 
 	// set zoom factor
 	const int displayedMapWidth = (int) ( (Video.getResolutionX() - HUD_TOTAL_WIDTH) / getZoom());
@@ -2940,7 +2938,7 @@
 	return true;
 }
 
-void cGameGUI::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cGameGUI::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	if (key.keysym.sym == SDLK_LSHIFT || key.keysym.sym == SDLK_RSHIFT)
 	{
@@ -2981,7 +2979,7 @@
 		cDialogYesNo yesNoDialog (lngPack.i18n ("Text~Comp~End_Game"));
 		if (yesNoDialog.show (client) == 0) end = true;
 	}
-	else if (activeItem && !activeItem->isDisabled() && activeItem->handleKeyInput (key.keysym, ch, this))
+	else if (activeItem && !activeItem->isDisabled() && activeItem->handleKeyInput (key.keysym, this))
 	{}
 	else if (key.keysym.sym == KeysList.KeyJumpToAction)
 	{
@@ -3970,7 +3968,7 @@
 	const int mouseTopY = static_cast<int> (min (mouseBox.startY, mouseBox.endY) * getTileSize());
 	const int mouseBottomX = static_cast<int> (max (mouseBox.startX, mouseBox.endX) * getTileSize());
 	const int mouseBottomY = static_cast<int> (max (mouseBox.startY, mouseBox.endY) * getTileSize());
-	const Uint32 color = 0x00FFFF00;
+	const Uint32 color = 0xFFFFFF00;
 	SDL_Rect d;
 
 	d.x = mouseTopX - zoomOffX + HUD_LEFT_WIDTH;
@@ -4115,7 +4113,6 @@
 	while (top.y > -479)
 	{
 		Video.draw();
-		mouse->draw (false, screen);
 		SDL_Delay (10);
 		top.y -= 10;
 		bottom.y += 10;
@@ -4134,7 +4131,6 @@
 	while (bottom.y > Video.getResolutionY() / 2)
 	{
 		Video.draw();
-		mouse->draw (false, screen);
 		SDL_Delay (10);
 		top.y += 10;
 		if (top.y > (Video.getResolutionY() / 2) - 479 - 9) top.y = (Video.getResolutionY() / 2) - 479;
@@ -4147,7 +4143,6 @@
 		SDL_BlitSurface (GraphicsData.gfx_panel_bottom, NULL, buffer, &tmp);
 	}
 	Video.draw();
-	mouse->draw (false, screen);
 	SDL_Delay (100);
 }
 
@@ -5209,14 +5204,14 @@
 	r2.w = (int) ( ( (float) (r1.w - 2) / unit.data.ammoMax) * unit.data.ammoCur);
 	r2.h = r1.h - 2;
 
-	SDL_FillRect (buffer, &r1, 0);
+	SDL_FillRect (buffer, &r1, 0xFF000000);
 
 	if (unit.data.ammoCur > unit.data.ammoMax / 2)
-		SDL_FillRect (buffer, &r2, 0x0004AE04);
+		SDL_FillRect (buffer, &r2, 0xFF04AE04);
 	else if (unit.data.ammoCur > unit.data.ammoMax / 4)
-		SDL_FillRect (buffer, &r2, 0x00DBDE00);
+		SDL_FillRect (buffer, &r2, 0xFFDBDE00);
 	else
-		SDL_FillRect (buffer, &r2, 0x00E60000);
+		SDL_FillRect (buffer, &r2, 0xFFE60000);
 }
 
 //------------------------------------------------------------------------------
@@ -5245,15 +5240,15 @@
 	r2.w = (int) ( ( (float) (r1.w - 2) / unit.data.hitpointsMax) * unit.data.hitpointsCur);
 	r2.h = r1.h - 2;
 
-	SDL_FillRect (buffer, &r1, 0);
+	SDL_FillRect (buffer, &r1, 0xFF000000);
 
 	Uint32 color;
 	if (unit.data.hitpointsCur > unit.data.hitpointsMax / 2)
-		color = 0x0004AE04; // green
+		color = 0xFF04AE04; // green
 	else if (unit.data.hitpointsCur > unit.data.hitpointsMax / 4)
-		color = 0x00DBDE00; // orange
+		color = 0xFFDBDE00; // orange
 	else
-		color = 0x00E60000; // red
+		color = 0xFFE60000; // red
 	SDL_FillRect (buffer, &r2, color);
 }
 
Index: hud.h
===================================================================
--- hud.h	(revision 3442)
+++ hud.h	(working copy)
@@ -466,7 +466,7 @@
 
 	void updateInfoTexts();
 
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 
 	const cClient* getClient() const { return client; }
 	cClient* getClient() { return client; }
Index: input.cpp
===================================================================
--- input.cpp	(revision 3450)
+++ input.cpp	(working copy)
@@ -35,13 +35,15 @@
 cInput::cInput() :
 	LastClickTicks (0)
 {
+#if 0 // TODO: [SDL2]: setting for repeat key ?
 	// enables that SDL puts the unicode values to the keyevents.
 	SDL_EnableUNICODE (1);
 	// enables keyrepetition
 	SDL_EnableKeyRepeat (SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
+#endif
 }
 
-void cInput::inputkey (cMenu& activeMenu, SDL_KeyboardEvent& key)
+void cInput::inputkey (cMenu& activeMenu, const SDL_KeyboardEvent& key)
 {
 	// give the key to the active menu
 	// But do not send events to a menu,
@@ -50,7 +52,7 @@
 	// after clicking the exit button
 	if (!activeMenu.exiting())
 	{
-		activeMenu.handleKeyInput (key, getUTF16Char (key.keysym.unicode));
+		activeMenu.handleKeyInput (key);
 	}
 }
 
@@ -86,8 +88,7 @@
 	}
 }
 
-
-void cInput::inputMouseButton (cMenu& activeMenu, SDL_MouseButtonEvent& button)
+void cInput::inputMouseButton (cMenu& activeMenu, const SDL_MouseButtonEvent& button)
 {
 	MouseState.x = button.x;
 	MouseState.y = button.y;
@@ -106,27 +107,7 @@
 			MouseState.rightButtonReleased = false;
 			MouseState.leftButtonReleased = false;
 		}
-		else if (button.button == SDL_BUTTON_WHEELUP)
-		{
-			MouseState.wheelUp = true;
-			MouseState.leftButtonReleased = false;
-			MouseState.rightButtonReleased = false;
-		}
-		else if (button.button == SDL_BUTTON_WHEELDOWN)
-		{
-			MouseState.wheelDown = true;
-			MouseState.leftButtonReleased = false;
-			MouseState.rightButtonReleased = false;
-		}
-
-		if (IsDoubleClicked())
-		{
-			MouseState.isDoubleClick = true;
-		}
-		else
-		{
-			MouseState.isDoubleClick = false;
-		}
+		MouseState.isDoubleClick = IsDoubleClicked();
 	}
 	else if (button.state == SDL_RELEASED)
 	{
@@ -142,8 +123,6 @@
 			MouseState.rightButtonReleased = true;
 			MouseState.leftButtonReleased = false;
 		}
-		else if (button.button == SDL_BUTTON_WHEELUP) MouseState.wheelUp = false;
-		else if (button.button == SDL_BUTTON_WHEELDOWN) MouseState.wheelDown = false;
 	}
 
 	// do not send events to a menu, after an event triggered the termination
@@ -155,6 +134,24 @@
 	}
 }
 
+void cInput::inputMouseButton (cMenu& activeMenu, const SDL_MouseWheelEvent& wheel)
+{
+	MouseState.wheelUp = false;
+	MouseState.wheelDown = false;
+	if (wheel.y > 0)
+	{
+		MouseState.wheelUp = true;
+		MouseState.leftButtonReleased = false;
+		MouseState.rightButtonReleased = false;
+	}
+	else if (wheel.y < 0)
+	{
+		MouseState.wheelDown = true;
+		MouseState.leftButtonReleased = false;
+		MouseState.rightButtonReleased = false;
+	}
+}
+
 std::string cInput::getUTF16Char (Uint16 ch)
 {
 	// convert from UTF-16 to UTF-8
Index: input.h
===================================================================
--- input.h	(revision 3442)
+++ input.h	(working copy)
@@ -45,14 +45,8 @@
 class cInput
 {
 private:
+	sMouseState MouseState;
 
-	sMouseState MouseState;
-	/**
-	 * Decodes the character from UTF-16 to UTF-8 and adds him to the input string.
-	 * @author alzi alias DoctorDeath
-	 * @param ch character which is to be added.
-	 */
-	std::string getUTF16Char (Uint16 ch);
 public:
 	cInput();
 	/**
@@ -60,13 +54,22 @@
 	 * If input is active the character will be added to the inpput string,
 	 * else the information will be given to the client to handle hotkeys.
 	 * @author alzi alias DoctorDeath
-	 * @param keysym SDL_keysym with pressed key information.
+	 * @param keysym SDL_Keysym with pressed key information.
 	 */
-	void inputkey (cMenu& activeMenu, SDL_KeyboardEvent& key);
+	void inputkey (cMenu& activeMenu, const SDL_KeyboardEvent& key);
 
 	long LastClickTicks;
-	void inputMouseButton (cMenu& avtiveMenu, SDL_MouseButtonEvent& button);
+	void inputMouseButton (cMenu& avtiveMenu, const SDL_MouseButtonEvent& button);
+	void inputMouseButton (cMenu& activeMenu, const SDL_MouseWheelEvent& wheel);
 	bool IsDoubleClicked();
+
+public:
+	/**
+	 * Decodes the character from UTF-16 to UTF-8 and adds him to the input string.
+	 * @author alzi alias DoctorDeath
+	 * @param ch character which is to be added.
+	 */
+	static std::string getUTF16Char (Uint16 ch);
 };
 
 EX cInput* InputHandler;
Index: keys.cpp
===================================================================
--- keys.cpp	(revision 3442)
+++ keys.cpp	(working copy)
@@ -139,6 +139,16 @@
 	return 1;
 }
 
+#if 0 // TODO: [SDL2]: obsolete keys... use scancode ?
+SDLK_KP0;SDLK_KP1;SDLK_KP2;SDLK_KP3;SDLK_KP4;
+SDLK_KP5;SDLK_KP6;SDLK_KP7;SDLK_KP8;SDLK_KP9;
+SDLK_NUMLOCK;SDLK_SCROLLOCK;
+SDLK_RMETA;SDLK_LMETA;
+SDLK_LSUPER;SDLK_RSUPER;
+SDLK_COMPOSE;SDLK_PRINT;SDLK_BREAK;SDLK_EURO;
+#endif
+
+
 // Liefert einen String mit dem Namen der Taste zurueck:
 const char* GetKeyString (SDLKey key)
 {
@@ -216,16 +226,6 @@
 		case SDLK_y: return "Y";
 		case SDLK_z: return "Z";
 		case SDLK_DELETE: return "DELETE";
-		case SDLK_KP0: return "KP0";
-		case SDLK_KP1: return "KP1";
-		case SDLK_KP2: return "KP2";
-		case SDLK_KP3: return "KP3";
-		case SDLK_KP4: return "KP4";
-		case SDLK_KP5: return "KP5";
-		case SDLK_KP6: return "KP6";
-		case SDLK_KP7: return "KP7";
-		case SDLK_KP8: return "KP8";
-		case SDLK_KP9: return "KP9";
 		case SDLK_KP_PERIOD: return "KP_PERIOD";
 		case SDLK_KP_DIVIDE: return "KP_DIVIDE";
 		case SDLK_KP_MULTIPLY: return "KP_MULTIPLY";
@@ -257,9 +257,7 @@
 		case SDLK_F13: return "F13";
 		case SDLK_F14: return "F14";
 		case SDLK_F15: return "F15";
-		case SDLK_NUMLOCK: return "NUMLOCK";
 		case SDLK_CAPSLOCK: return "CAPSLOCK";
-		case SDLK_SCROLLOCK: return "SCROLLOCK";
 		case SDLK_RSHIFT: return "RSHIFT";
 		case SDLK_LSHIFT: return "LSHIFT";
 		case SDLK_RCTRL: return "RCTRL";
@@ -266,19 +264,11 @@
 		case SDLK_LCTRL: return "LCTRL";
 		case SDLK_RALT: return "RALT";
 		case SDLK_LALT: return "LALT";
-		case SDLK_RMETA: return "RMETA";
-		case SDLK_LMETA: return "LMETA";
-		case SDLK_LSUPER: return "LSUPER";
-		case SDLK_RSUPER: return "RSUPER";
 		case SDLK_MODE: return "MODE";
-		case SDLK_COMPOSE: return "COMPOSE";
 		case SDLK_HELP: return "HELP";
-		case SDLK_PRINT: return "PRINT";
 		case SDLK_SYSREQ: return "SYSREQ";
-		case SDLK_BREAK: return "BREAK";
 		case SDLK_MENU: return "MENU";
 		case SDLK_POWER: return "POWER";
-		case SDLK_EURO: return "EURO";
 		case SDLK_UNDO: return "UNDO";
 		default: return "?";
 	}
@@ -359,16 +349,6 @@
 	if (!key.compare ("Y")) return SDLK_y;
 	if (!key.compare ("Z")) return SDLK_z;
 	if (!key.compare ("DELETE")) return SDLK_DELETE;
-	if (!key.compare ("KP0")) return SDLK_KP0;
-	if (!key.compare ("KP1")) return SDLK_KP1;
-	if (!key.compare ("KP2")) return SDLK_KP2;
-	if (!key.compare ("KP3")) return SDLK_KP3;
-	if (!key.compare ("KP4")) return SDLK_KP4;
-	if (!key.compare ("KP5")) return SDLK_KP5;
-	if (!key.compare ("KP6")) return SDLK_KP6;
-	if (!key.compare ("KP7")) return SDLK_KP7;
-	if (!key.compare ("KP8")) return SDLK_KP8;
-	if (!key.compare ("KP9")) return SDLK_KP9;
 	if (!key.compare ("KP_PERIOD")) return SDLK_KP_PERIOD;
 	if (!key.compare ("KP_DIVIDE")) return SDLK_KP_DIVIDE;
 	if (!key.compare ("KP_MULTIPLY")) return SDLK_KP_MULTIPLY;
@@ -400,9 +380,7 @@
 	if (!key.compare ("F13")) return SDLK_F13;
 	if (!key.compare ("F14")) return SDLK_F14;
 	if (!key.compare ("F15")) return SDLK_F15;
-	if (!key.compare ("NUMLOCK")) return SDLK_NUMLOCK;
 	if (!key.compare ("CAPSLOCK")) return SDLK_CAPSLOCK;
-	if (!key.compare ("SCROLLOCK")) return SDLK_SCROLLOCK;
 	if (!key.compare ("RSHIFT")) return SDLK_RSHIFT;
 	if (!key.compare ("LSHIFT")) return SDLK_LSHIFT;
 	if (!key.compare ("RCTRL")) return SDLK_RCTRL;
@@ -409,19 +387,11 @@
 	if (!key.compare ("LCTRL")) return SDLK_LCTRL;
 	if (!key.compare ("RALT")) return SDLK_RALT;
 	if (!key.compare ("LALT")) return SDLK_LALT;
-	if (!key.compare ("RMETA")) return SDLK_RMETA;
-	if (!key.compare ("LMETA")) return SDLK_LMETA;
-	if (!key.compare ("LSUPER")) return SDLK_LSUPER;
-	if (!key.compare ("RSUPER")) return SDLK_RSUPER;
 	if (!key.compare ("MODE")) return SDLK_MODE;
-	if (!key.compare ("COMPOSE")) return SDLK_COMPOSE;
 	if (!key.compare ("HELP")) return SDLK_HELP;
-	if (!key.compare ("PRINT")) return SDLK_PRINT;
 	if (!key.compare ("SYSREQ")) return SDLK_SYSREQ;
-	if (!key.compare ("BREAK")) return SDLK_BREAK;
 	if (!key.compare ("MENU")) return SDLK_MENU;
 	if (!key.compare ("POWER")) return SDLK_POWER;
-	if (!key.compare ("EURO")) return SDLK_EURO;
 	if (!key.compare ("UNDO")) return SDLK_UNDO;
 	return SDLK_UNKNOWN;
 }
Index: keys.h
===================================================================
--- keys.h	(revision 3442)
+++ keys.h	(working copy)
@@ -22,6 +22,10 @@
 #include <string>
 #include "defines.h"
 
+#if 1 // TODO [SDL2]: use scancode or keycode ?
+typedef SDL_Keycode SDLKey;
+#endif
+
 // Globale Daten /////////////////////////////////////////////////////////////
 class cKeysList
 {
Index: loaddata.cpp
===================================================================
--- loaddata.cpp	(revision 3442)
+++ loaddata.cpp	(working copy)
@@ -357,12 +357,12 @@
 			if (pos == 0)   //need full line for first entry version information
 			{
 				SDL_BlitSurface (buffer, NULL, screen, NULL);
-				SDL_UpdateRect (screen, rDest.x, rDest.y + rDest.h * pos, rDest.w + rDest2.w, rDest.h);
+				Video.draw();
 			}
 			else
 			{
 				SDL_BlitSurface (buffer, &rSrc, screen, &rSrc);
-				SDL_UpdateRect (screen, rDest.x, rDest.y + rDest.h * pos, rDest.w, rDest.h);
+				Video.draw();
 			}
 			break;
 
@@ -380,7 +380,7 @@
 		rSrc = rDest2;
 		rSrc.y = rDest2.y + rDest2.h * pos;
 		SDL_BlitSurface (buffer, &rSrc, screen, &rSrc);
-		SDL_UpdateRect (screen, rDest2.x, rDest2.y + rDest2.h * pos, rDest2.w, rDest2.h);
+		Video.draw();
 	}
 }
 
@@ -474,8 +474,8 @@
 
 	dest[0] = LoadPCX (filepath);
 	dest[1] = CloneSDLSurface (dest[0]);
-	SDL_SetAlpha (dest[0], SDL_SRCALPHA, alpha);
-	SDL_SetAlpha (dest[1], SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (dest[0], alpha);
+	SDL_SetSurfaceAlphaMod (dest[1], alpha);
 
 	filepath.insert (0, "Effectalpha loaded: ");
 	Log.write (filepath.c_str(), LOG_TYPE_DEBUG);
@@ -607,7 +607,7 @@
 	LoadEffectGraphicToSurface (fx_rocket, path, "rocket.pcx");
 	LoadEffectAlphaToSurface (fx_dark_smoke, path, "dark_smoke.pcx", 100);
 	LoadEffectAlphaToSurface (fx_tracks, path, "tracks.pcx", 100);
-	LoadEffectAlphaToSurface (fx_corpse, path, "corpse.pcx", 255);
+	LoadEffectAlphaToSurface (fx_corpse, path, "corpse.pcx", 254);
 	LoadEffectAlphaToSurface (fx_absorb, path, "absorb.pcx", 150);
 }
 
@@ -855,17 +855,17 @@
 
 	Log.write ("Shadowgraphics...", LOG_TYPE_DEBUG);
 	// Shadow:
-	GraphicsData.gfx_shadow = SDL_CreateRGBSurface (Video.getSurfaceType(), Video.getResolutionX(),
-													Video.getResolutionY(), Video.getColDepth(), 0, 0, 0, 0);
+	GraphicsData.gfx_shadow = SDL_CreateRGBSurface (0, Video.getResolutionX(), Video.getResolutionY(),
+													Video.getColDepth(), 0, 0, 0, 0);
 	SDL_FillRect (GraphicsData.gfx_shadow, NULL, 0x0);
-	SDL_SetAlpha (GraphicsData.gfx_shadow, SDL_SRCALPHA, 50);
-	GraphicsData.gfx_tmp = SDL_CreateRGBSurface (Video.getSurfaceType(), 128, 128, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (GraphicsData.gfx_tmp, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_shadow, 50);
+	GraphicsData.gfx_tmp = SDL_CreateRGBSurface (0, 128, 128, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (GraphicsData.gfx_tmp, SDL_TRUE, 0xFF00FF);
 
 	// Glas:
 	Log.write ("Glassgraphic...", LOG_TYPE_DEBUG);
 	LoadGraphicToSurface (GraphicsData.gfx_destruction_glas, path, "destruction_glas.pcx");
-	SDL_SetAlpha (GraphicsData.gfx_destruction_glas, SDL_SRCALPHA, 150);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_destruction_glas, 150);
 
 	// Waypoints:
 	Log.write ("Waypointgraphics...", LOG_TYPE_DEBUG);
@@ -922,7 +922,7 @@
 	if (LoadGraphicToSurface (res_metal_org, path, "res.pcx") == 1)
 	{
 		res_metal = CloneSDLSurface (res_metal_org);
-		SDL_SetColorKey (res_metal, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (res_metal, SDL_TRUE, 0xFF00FF);
 	}
 
 	// gold
@@ -929,7 +929,7 @@
 	if (LoadGraphicToSurface (res_gold_org, path, "gold.pcx") == 1)
 	{
 		res_gold = CloneSDLSurface (res_gold_org);
-		SDL_SetColorKey (res_gold, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (res_gold, SDL_TRUE, 0xFF00FF);
 	}
 
 	// fuel
@@ -936,7 +936,7 @@
 	if (LoadGraphicToSurface (res_oil_org, path, "fuel.pcx") == 1)
 	{
 		res_oil = CloneSDLSurface (res_oil_org);
-		SDL_SetColorKey (res_oil, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (res_oil, SDL_TRUE, 0xFF00FF);
 	}
 }
 
@@ -1040,8 +1040,8 @@
 			SDL_Rect rcDest;
 			for (int n = 0; n < 8; n++)
 			{
-				ui.img[n] = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
-				SDL_SetColorKey (ui.img[n], SDL_SRCCOLORKEY, 0x00FFFFFF);
+				ui.img[n] = SDL_CreateRGBSurface (0, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
+				SDL_SetColorKey (ui.img[n], SDL_TRUE, 0x00FFFFFF);
 				SDL_FillRect (ui.img[n], NULL, 0x00FF00FF);
 
 				for (int j = 0; j < 13; j++)
@@ -1066,16 +1066,16 @@
 						}
 					}
 				}
-				ui.img_org[n] = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
-				SDL_SetColorKey (ui.img[n], SDL_SRCCOLORKEY, 0x00FFFFFF);
+				ui.img_org[n] = SDL_CreateRGBSurface (0, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
+				SDL_SetColorKey (ui.img[n], SDL_TRUE, 0x00FFFFFF);
 				SDL_FillRect (ui.img_org[n], NULL, 0x00FFFFFF);
 				SDL_BlitSurface (ui.img[n], NULL, ui.img_org[n], NULL);
 
-				ui.shw[n] = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
-				SDL_SetColorKey (ui.shw[n], SDL_SRCCOLORKEY, 0x00FF00FF);
+				ui.shw[n] = SDL_CreateRGBSurface (0, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
+				SDL_SetColorKey (ui.shw[n], SDL_TRUE, 0x00FF00FF);
 				SDL_FillRect (ui.shw[n], NULL, 0x00FF00FF);
-				ui.shw_org[n] = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
-				SDL_SetColorKey (ui.shw_org[n], SDL_SRCCOLORKEY, 0x00FF00FF);
+				ui.shw_org[n] = SDL_CreateRGBSurface (0, 64 * 13, 64, Video.getColDepth(), 0, 0, 0, 0);
+				SDL_SetColorKey (ui.shw_org[n], SDL_TRUE, 0x00FF00FF);
 				SDL_FillRect (ui.shw_org[n], NULL, 0x00FF00FF);
 
 				rcDest.x = 3;
@@ -1091,8 +1091,8 @@
 				}
 				SDL_UnlockSurface (ui.shw_org[n]);
 				SDL_BlitSurface (ui.shw_org[n], NULL, ui.shw[n], NULL);
-				SDL_SetAlpha (ui.shw_org[n], SDL_SRCALPHA, 50);
-				SDL_SetAlpha (ui.shw[n], SDL_SRCALPHA, 50);
+				SDL_SetSurfaceAlphaMod (ui.shw_org[n], 50);
+				SDL_SetSurfaceAlphaMod (ui.shw[n], 50);
 			}
 		}
 		// load other vehicle graphics
@@ -1110,8 +1110,8 @@
 				{
 					ui.img_org[n] = LoadPCX (sTmpString);
 					ui.img[n] = CloneSDLSurface (ui.img_org[n]);
-					SDL_SetColorKey (ui.img_org[n], SDL_SRCCOLORKEY, 0xFFFFFF);
-					SDL_SetColorKey (ui.img[n], SDL_SRCCOLORKEY, 0xFFFFFF);
+					SDL_SetColorKey (ui.img_org[n], SDL_TRUE, 0xFFFFFF);
+					SDL_SetColorKey (ui.img[n], SDL_TRUE, 0xFFFFFF);
 				}
 				else
 				{
@@ -1125,7 +1125,7 @@
 				{
 					ui.shw_org[n] = LoadPCX (sTmpString);
 					ui.shw[n] = CloneSDLSurface (ui.shw_org[n]);
-					SDL_SetAlpha (ui.shw[n], SDL_SRCALPHA, 50);
+					SDL_SetSurfaceAlphaMod (ui.shw[n], 50);
 				}
 				else
 				{
@@ -1210,8 +1210,8 @@
 			{
 				ui.build_org = LoadPCX (sTmpString);
 				ui.build = CloneSDLSurface (ui.build_org);
-				SDL_SetColorKey (ui.build_org, SDL_SRCCOLORKEY, 0xFFFFFF);
-				SDL_SetColorKey (ui.build, SDL_SRCCOLORKEY, 0xFFFFFF);
+				SDL_SetColorKey (ui.build_org, SDL_TRUE, 0xFFFFFF);
+				SDL_SetColorKey (ui.build, SDL_TRUE, 0xFFFFFF);
 			}
 			else
 			{
@@ -1227,7 +1227,7 @@
 			{
 				ui.build_shw_org = LoadPCX (sTmpString);
 				ui.build_shw = CloneSDLSurface (ui.build_shw_org);
-				SDL_SetAlpha (ui.build_shw, SDL_SRCALPHA, 50);
+				SDL_SetSurfaceAlphaMod (ui.build_shw, 50);
 			}
 			else
 			{
@@ -1255,8 +1255,8 @@
 			{
 				ui.clear_small_org = LoadPCX (sTmpString);
 				ui.clear_small = CloneSDLSurface (ui.clear_small_org);
-				SDL_SetColorKey (ui.clear_small_org, SDL_SRCCOLORKEY, 0xFFFFFF);
-				SDL_SetColorKey (ui.clear_small, SDL_SRCCOLORKEY, 0xFFFFFF);
+				SDL_SetColorKey (ui.clear_small_org, SDL_TRUE, 0xFFFFFF);
+				SDL_SetColorKey (ui.clear_small, SDL_TRUE, 0xFFFFFF);
 			}
 			else
 			{
@@ -1272,7 +1272,7 @@
 			{
 				ui.clear_small_shw_org = LoadPCX (sTmpString);
 				ui.clear_small_shw = CloneSDLSurface (ui.clear_small_shw_org);
-				SDL_SetAlpha (ui.clear_small_shw, SDL_SRCALPHA, 50);
+				SDL_SetSurfaceAlphaMod (ui.clear_small_shw, 50);
 			}
 			else
 			{
@@ -1288,8 +1288,8 @@
 			{
 				ui.build_org = LoadPCX (sTmpString);
 				ui.build = CloneSDLSurface (ui.build_org);
-				SDL_SetColorKey (ui.build_org, SDL_SRCCOLORKEY, 0xFFFFFF);
-				SDL_SetColorKey (ui.build, SDL_SRCCOLORKEY, 0xFFFFFF);
+				SDL_SetColorKey (ui.build_org, SDL_TRUE, 0xFFFFFF);
+				SDL_SetColorKey (ui.build, SDL_TRUE, 0xFFFFFF);
 			}
 			else
 			{
@@ -1305,7 +1305,7 @@
 			{
 				ui.build_shw_org = LoadPCX (sTmpString);
 				ui.build_shw = CloneSDLSurface (ui.build_shw_org);
-				SDL_SetAlpha (ui.build_shw, SDL_SRCALPHA, 50);
+				SDL_SetSurfaceAlphaMod (ui.build_shw, 50);
 			}
 			else
 			{
@@ -1594,8 +1594,8 @@
 		{
 			ui.img_org = LoadPCX (sTmpString);
 			ui.img = CloneSDLSurface (ui.img_org);
-			SDL_SetColorKey (ui.img_org, SDL_SRCCOLORKEY, 0xFFFFFF);
-			SDL_SetColorKey (ui.img, SDL_SRCCOLORKEY, 0xFFFFFF);
+			SDL_SetColorKey (ui.img_org, SDL_TRUE, 0xFFFFFF);
+			SDL_SetColorKey (ui.img, SDL_TRUE, 0xFFFFFF);
 		}
 		else
 		{
@@ -1609,7 +1609,7 @@
 		{
 			ui.shw_org = LoadPCX (sTmpString);
 			ui.shw     = CloneSDLSurface (ui.shw_org);
-			SDL_SetAlpha (ui.shw, SDL_SRCALPHA, 50);
+			SDL_SetSurfaceAlphaMod (ui.shw, 50);
 		}
 
 		// load video
@@ -1633,7 +1633,7 @@
 			{
 				ui.eff_org = LoadPCX (sTmpString);
 				ui.eff = CloneSDLSurface (ui.eff_org);
-				SDL_SetAlpha (ui.eff, SDL_SRCALPHA, 10);
+				SDL_SetSurfaceAlphaMod (ui.eff, 10);
 			}
 		}
 		else
@@ -1655,16 +1655,16 @@
 			b.isConnectorGraphic = true;
 			UnitsData.ptr_connector = ui.img;
 			UnitsData.ptr_connector_org = ui.img_org;
-			SDL_SetColorKey (UnitsData.ptr_connector, SDL_SRCCOLORKEY, 0xFF00FF);
+			SDL_SetColorKey (UnitsData.ptr_connector, SDL_TRUE, 0xFF00FF);
 			UnitsData.ptr_connector_shw = ui.shw;
 			UnitsData.ptr_connector_shw_org = ui.shw_org;
-			SDL_SetColorKey (UnitsData.ptr_connector_shw, SDL_SRCCOLORKEY, 0xFF00FF);
+			SDL_SetColorKey (UnitsData.ptr_connector_shw, SDL_TRUE, 0xFF00FF);
 		}
 		else if (b.ID == UnitsData.specialIDSmallBeton)
 		{
 			UnitsData.ptr_small_beton = ui.img;
 			UnitsData.ptr_small_beton_org = ui.img_org;
-			SDL_SetColorKey (UnitsData.ptr_small_beton, SDL_SRCCOLORKEY, 0xFF00FF);
+			SDL_SetColorKey (UnitsData.ptr_small_beton, SDL_TRUE, 0xFF00FF);
 		}
 
 		// Check if there is more than one frame
@@ -1680,12 +1680,12 @@
 		UnitsData.dirt_big = CloneSDLSurface (UnitsData.dirt_big_org);
 		LoadGraphicToSurface (UnitsData.dirt_big_shw_org, cSettings::getInstance().getBuildingsPath().c_str(), "dirt_big_shw.pcx");
 		UnitsData.dirt_big_shw = CloneSDLSurface (UnitsData.dirt_big_shw_org);
-		if (UnitsData.dirt_big_shw) SDL_SetAlpha (UnitsData.dirt_big_shw, SDL_SRCALPHA, 50);
+		if (UnitsData.dirt_big_shw) SDL_SetSurfaceAlphaMod (UnitsData.dirt_big_shw, 50);
 		LoadGraphicToSurface (UnitsData.dirt_small_org, cSettings::getInstance().getBuildingsPath().c_str(), "dirt_small.pcx");
 		UnitsData.dirt_small = CloneSDLSurface (UnitsData.dirt_small_org);
 		LoadGraphicToSurface (UnitsData.dirt_small_shw_org, cSettings::getInstance().getBuildingsPath().c_str(), "dirt_small_shw.pcx");
 		UnitsData.dirt_small_shw = CloneSDLSurface (UnitsData.dirt_small_shw_org);
-		if (UnitsData.dirt_small_shw) SDL_SetAlpha (UnitsData.dirt_small_shw, SDL_SRCALPHA, 50);
+		if (UnitsData.dirt_small_shw) SDL_SetSurfaceAlphaMod (UnitsData.dirt_small_shw, 50);
 	}
 	return 1;
 }
Index: log.cpp
===================================================================
--- log.cpp	(revision 3449)
+++ log.cpp	(working copy)
@@ -104,7 +104,7 @@
 		fprintf (stderr, "(EE): Couldn't open maxr.log!\n Please check file/directory permissions\n");
 		return false;
 	}
-	if (blocks < 0)
+	if (blocks <= 0)
 	{
 		fprintf (stderr, "(EE): Couldn't read maxr.log!\n Please check file/directory permissions\n");
 
@@ -173,9 +173,9 @@
 {
 	if (logfile)
 	{
-		int const wrote = SDL_RWwrite (logfile, str.c_str(), 1, (int) str.length());
+		const int wrote = SDL_RWwrite (logfile, str.c_str(), 1, (int) str.length());
 		std::cout << str;
-		if (wrote < 0)   //sanity check - was file writable?
+		if (wrote <= 0)   //sanity check - was file writable?
 		{
 			fprintf (stderr, "Couldn't write to maxr.log\nPlease check permissions for maxr.log\nLog message was:\n%s", str.c_str());
 			return -1;
Index: main.cpp
===================================================================
--- main.cpp	(revision 3442)
+++ main.cpp	(working copy)
@@ -27,7 +27,6 @@
 #include <SDL_thread.h>
 #include <SDL_net.h>
 #include <SDL_mixer.h>
-#include <SDL_getenv.h>
 
 #define __main__
 #include "main.h"
@@ -111,7 +110,7 @@
 
 	// load files
 	int loadingState = LOAD_GOING;
-	SDL_Thread* dataThread = SDL_CreateThread (LoadData, &loadingState);
+	SDL_Thread* dataThread = SDL_CreateThread (LoadData, "loadingData", &loadingState);
 
 	SDL_Event event;
 	while (loadingState != LOAD_FINISHED)
@@ -124,8 +123,12 @@
 		}
 		while (SDL_PollEvent (&event))
 		{
-			if (event.type == SDL_ACTIVEEVENT && !DEDICATED_SERVER)
-				SDL_UpdateRect (screen, 0, 0, 0, 0);
+			if (!DEDICATED_SERVER
+				&& event.type == SDL_WINDOWEVENT
+				&& event.window.event == SDL_WINDOWEVENT_EXPOSED)
+			{
+				Video.draw();
+			}
 		}
 		SDL_Delay (100);
 	}
@@ -172,7 +175,6 @@
 	else
 	{
 		Video.setResolution (Video.getResolutionX(), Video.getResolutionY(), true);
-		SDL_ShowCursor (0);
 		Video.clearBuffer();
 
 		mouse = new cMouse;
@@ -335,7 +337,7 @@
 	if (height > scr->h && dest) height = scr->h;
 
 	// generate new surface if necessary
-	if (dest == NULL) surface = SDL_CreateRGBSurface (scr->flags, width, height, scr->format->BitsPerPixel, scr->format->Rmask, scr->format->Gmask, scr->format->Bmask, scr->format->Amask);
+	if (dest == NULL) surface = SDL_CreateRGBSurface (0, width, height, scr->format->BitsPerPixel, scr->format->Rmask, scr->format->Gmask, scr->format->Bmask, scr->format->Amask);
 	else
 	{
 		// else set the size of the old one
@@ -421,8 +423,8 @@
 SDL_Surface* CreatePfeil (int p1x, int p1y, int p2x, int p2y, int p3x, int p3y, unsigned int color, int size)
 {
 	SDL_Surface* sf;
-	sf = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, size, size, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (sf, SDL_SRCCOLORKEY, 0x00FF00FF);
+	sf = SDL_CreateRGBSurface (0, size, size, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (sf, SDL_TRUE, 0x00FF00FF);
 	SDL_FillRect (sf, NULL, 0x00FF00FF);
 	SDL_LockSurface (sf);
 
@@ -974,8 +976,8 @@
 	if (!dst || !src) return;
 
 	//check surface formats
-	if (!dst->format->Amask) return;
-	if (src->format->Amask || ! (src->flags & SDL_SRCALPHA)) return;
+	if (!dst->format->Amask || src->format->Amask) return;
+	if (SDL_GetSurfaceAlphaMod(src, NULL) != 0) return;
 
 	if (srcrect == NULL)
 	{
@@ -1037,7 +1039,8 @@
 	if (SDL_MUSTLOCK (dst)) SDL_LockSurface (dst);
 
 	//setup needed variables
-	const Uint32 srcAlpha = src->format->alpha;
+	Uint8 srcAlpha = 0;
+	SDL_GetSurfaceAlphaMod (src, &srcAlpha);
 	const int srmask = src->format->Rmask;
 	const int sgmask = src->format->Gmask;
 	const int sbmask = src->format->Bmask;
@@ -1049,8 +1052,8 @@
 	const int gshift = src->format->Gshift - dst->format->Gshift;
 	const int bshift = src->format->Bshift - dst->format->Bshift;
 	const int ashift = dst->format->Ashift;
-	const Uint32 colorKey = src->format->colorkey;
-	const bool useColorKey = (src->flags & SDL_SRCCOLORKEY) != 0;
+	Uint32 colorKey = 0;
+	const bool useColorKey = SDL_GetColorKey (src, &colorKey) == 0;
 
 	Uint32* dstPixel = static_cast<Uint32*> (dst->pixels) + dstrect->x + dstrect->y * dst->w;
 	Uint32* srcPixel = static_cast<Uint32*> (src->pixels) + srcrect->x + srcrect->y * src->w;
@@ -1107,7 +1110,8 @@
 
 void blittAlphaSurface (SDL_Surface* src, SDL_Rect* srcrect, SDL_Surface* dst, SDL_Rect* dstrect)
 {
-	if (dst->format->Amask && (src->flags & SDL_SRCALPHA))
+	// TODO: [SDL2] special blitSurface seems useless.
+	if (dst->format->Amask && SDL_GetSurfaceAlphaMod(src, NULL) == 0)
 		blittPerSurfaceAlphaToAlphaChannel (src, srcrect, dst, dstrect);
 	else
 		SDL_BlitSurface (src, srcrect, dst, dstrect);
Index: map.cpp
===================================================================
--- map.cpp	(revision 3450)
+++ map.cpp	(working copy)
@@ -28,6 +28,14 @@
 #include "vehicles.h"
 #include "video.h"
 
+#if 1 // TODO: [SDL2]: SDL_SetColors
+inline void SDL_SetColors (SDL_Surface* surface, SDL_Color* colors, int index, int size)
+{
+	SDL_SetPaletteColors (surface->format->palette, colors, index, size);
+}
+#endif
+
+
 sTerrain::sTerrain() :
 	water (false),
 	coast (false),
@@ -250,6 +258,8 @@
 		palette_shw[i].r = (unsigned char) (palette[i].r * 0.6f);
 		palette_shw[i].g = (unsigned char) (palette[i].g * 0.6f);
 		palette_shw[i].b = (unsigned char) (palette[i].b * 0.6f);
+		palette[i].a = 255;
+		palette_shw[i].a = 255;
 	}
 
 	// Load necessary Terrain Graphics
@@ -314,13 +324,13 @@
 	return true;
 }
 
-/*static*/SDL_Surface* cStaticMap::loadTerrGraph (SDL_RWops* fpMapFile, int iGraphicsPos, SDL_Color* Palette, int iNum)
+/*static*/SDL_Surface* cStaticMap::loadTerrGraph (SDL_RWops* fpMapFile, int iGraphicsPos, const SDL_Color (&colors)[256], int iNum)
 {
 	// Create new surface and copy palette
-	AutoSurface surface (SDL_CreateRGBSurface (SDL_SWSURFACE, 64, 64, 8, 0, 0, 0, 0));
+	AutoSurface surface (SDL_CreateRGBSurface (0, 64, 64, 8, 0, 0, 0, 0));
 	surface->pitch = surface->w;
 
-	SDL_SetColors (surface, Palette, 0, 256);
+	SDL_SetPaletteColors (surface->format->palette, colors, 0, 256);
 
 	// Go to position of filedata
 	SDL_RWseek (fpMapFile, iGraphicsPos + 64 * 64 * (iNum), SEEK_SET);
@@ -353,7 +363,7 @@
 	SDL_RWseek (mapFile, 64 * 64 * sGraphCount, SEEK_CUR);
 	SDL_RWread (mapFile, &Palette, 3, 256);
 
-	AutoSurface mapSurface (SDL_CreateRGBSurface (SDL_SWSURFACE, size, size, 8, 0, 0, 0, 0));
+	AutoSurface mapSurface (SDL_CreateRGBSurface (0, size, size, 8, 0, 0, 0, 0));
 	mapSurface->pitch = mapSurface->w;
 
 	mapSurface->format->palette->ncolors = 256;
@@ -388,20 +398,20 @@
 	//This is needed to make sure, that the pixeldata is copied 1:1
 
 	//copy the normal terrains
-	terrains[iNum].sf_org = SDL_CreateRGBSurface (Video.getSurfaceType(), 64, 64, 8, 0, 0, 0, 0);
-	SDL_SetColors (terrains[iNum].sf_org, surface->format->palette->colors, 0, 256);
+	terrains[iNum].sf_org = SDL_CreateRGBSurface (0, 64, 64, 8, 0, 0, 0, 0);
+	SDL_SetPaletteColors (terrains[iNum].sf_org->format->palette, surface->format->palette->colors, 0, 256);
 	SDL_BlitSurface (surface, NULL, terrains[iNum].sf_org, NULL);
 
-	terrains[iNum].sf = SDL_CreateRGBSurface (Video.getSurfaceType(), 64, 64, 8, 0, 0, 0, 0);
-	SDL_SetColors (terrains[iNum].sf, surface->format->palette->colors, 0, 256);
+	terrains[iNum].sf = SDL_CreateRGBSurface (0, 64, 64, 8, 0, 0, 0, 0);
+	SDL_SetPaletteColors (terrains[iNum].sf->format->palette, surface->format->palette->colors, 0, 256);
 	SDL_BlitSurface (surface, NULL, terrains[iNum].sf, NULL);
 
 	//copy the terrains with fog
-	terrains[iNum].shw_org = SDL_CreateRGBSurface (Video.getSurfaceType(), 64, 64, 8, 0, 0, 0, 0);
+	terrains[iNum].shw_org = SDL_CreateRGBSurface (0, 64, 64, 8, 0, 0, 0, 0);
 	SDL_SetColors (terrains[iNum].shw_org, surface->format->palette->colors, 0, 256);
 	SDL_BlitSurface (surface, NULL, terrains[iNum].shw_org, NULL);
 
-	terrains[iNum].shw = SDL_CreateRGBSurface (Video.getSurfaceType(), 64, 64, 8, 0, 0, 0, 0);
+	terrains[iNum].shw = SDL_CreateRGBSurface (0, 64, 64, 8, 0, 0, 0, 0);
 	SDL_SetColors (terrains[iNum].shw, surface->format->palette->colors, 0, 256);
 	SDL_BlitSurface (surface, NULL, terrains[iNum].shw, NULL);
 
@@ -451,7 +461,7 @@
 
 SDL_Surface* cStaticMap::createBigSurface (int sizex, int sizey) const
 {
-	SDL_Surface* mapSurface = SDL_CreateRGBSurface (Video.getSurfaceType(), sizex, sizey, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_Surface* mapSurface = SDL_CreateRGBSurface (0, sizex, sizey, Video.getColDepth(), 0, 0, 0, 0);
 
 	if (SDL_MUSTLOCK (mapSurface)) SDL_LockSurface (mapSurface);
 	for (int x = 0; x < mapSurface->w; ++x)
Index: map.h
===================================================================
--- map.h	(revision 3442)
+++ map.h	(working copy)
@@ -127,7 +127,7 @@
 	void scaleSurfaces (int pixelSize);
 	static SDL_Surface* loadMapPreview(const std::string& mapPath, int* mapSize = NULL);
 private:
-	static SDL_Surface* loadTerrGraph (SDL_RWops* fpMapFile, int iGraphicsPos, SDL_Color* Palette, int iNum);
+	static SDL_Surface* loadTerrGraph (SDL_RWops* fpMapFile, int iGraphicsPos, const SDL_Color (&colors)[256], int iNum);
 	void copySrfToTerData (SDL_Surface* surface, int iNum);
 private:
 	std::string filename;   // Name of the current map
Index: mapdownload.cpp
===================================================================
--- mapdownload.cpp	(revision 3450)
+++ mapdownload.cpp	(working copy)
@@ -269,7 +269,7 @@
 void cMapSender::runInThread()
 {
 	// the thread will quit, when it finished uploading the map
-	thread = SDL_CreateThread (mapSenderThreadFunction, this);
+	thread = SDL_CreateThread (mapSenderThreadFunction, "mapSender", this);
 }
 
 //------------------------------------------------------------------------------
Index: menuitems.cpp
===================================================================
--- menuitems.cpp	(revision 3446)
+++ menuitems.cpp	(working copy)
@@ -442,10 +442,10 @@
 {
 	if (image_ != NULL)
 	{
-		image = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, image_->w, image_->h, Video.getColDepth(), 0, 0, 0, 0);
+		image = SDL_CreateRGBSurface (0, image_->w, image_->h, Video.getColDepth(), 0, 0, 0, 0);
 
 		SDL_FillRect (image, NULL, 0xFF00FF);
-		SDL_SetColorKey (image, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (image, SDL_TRUE, 0xFF00FF);
 
 		SDL_BlitSurface (image_, NULL, image, NULL);
 
@@ -702,8 +702,8 @@
 			src.y = isClicked ? 0 : 132;
 			break;
 	}
-	surface = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xFF00FF);
+	surface = SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (surface, SDL_TRUE, 0xFF00FF);
 	SDL_FillRect (surface, NULL, 0xFF00FF);
 	if (buttonType >= BUTTON_TYPE_HUD_HELP && buttonType <= BUTTON_TYPE_HUD_STOP) SDL_BlitSurface (GraphicsData.gfx_hud_stuff, &src, surface, NULL);
 	else SDL_BlitSurface (GraphicsData.gfx_menu_stuff, &src, surface, NULL);
@@ -716,7 +716,6 @@
 	renewButtonSurface();
 	draw();
 	Video.draw();
-	mouse->draw (false, screen);
 }
 
 int cMenuButton::getTextYOffset() const
@@ -899,7 +898,6 @@
 	}
 
 	Video.draw();
-	mouse->draw (false, screen);
 }
 
 void cMenuDestroyButton::animationCallback()
@@ -1048,7 +1046,7 @@
 	}
 	if (src.w > 0)
 	{
-		surface = SDL_CreateRGBSurface (Video.getSurfaceType(), src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
+		surface = SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
 		if (buttonType >= CHECKBOX_HUD_INDEX_00 && buttonType <= CHECKBOX_HUD_PLAYERS) SDL_BlitSurface (GraphicsData.gfx_hud_stuff, &src, surface, NULL);
 		else SDL_BlitSurface (GraphicsData.gfx_menu_stuff, &src, surface, NULL);
 	}
@@ -1070,7 +1068,6 @@
 	}
 	draw();
 	Video.draw();
-	mouse->draw (false, screen);
 	return true;
 }
 
@@ -1112,7 +1109,7 @@
 			font->showText (position.x, position.y, text, fontType);
 			if (checked)
 			{
-				const Uint32 selection_color (0x00E3DACF);
+				const Uint32 selection_color (0xFFE3DACF);
 				const SDL_Rect dest = {Sint16 (position.x - 2), Sint16 (position.y - 1), Uint16 (position.w + 5), Uint16 (position.h + 2) };
 				DrawRectangle (buffer, dest, selection_color);
 			}
@@ -1209,7 +1206,7 @@
 
 void cMenuRadioGroup::clicked (void* parent)
 {
-	mouse->GetPos();
+	mouse->updatePos();
 	for (unsigned int i = 0; i < buttonList.size(); i++)
 	{
 		if (buttonList[i]->overItem (mouse->x, mouse->y))
@@ -1252,8 +1249,8 @@
 void cMenuUnitListItem::init()
 {
 	const int UNIT_IMAGE_SIZE = 32;
-	surface = SDL_CreateRGBSurface (SDL_SRCCOLORKEY, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0x00FF00FF);
+	surface = SDL_CreateRGBSurface (0, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (surface, SDL_TRUE, 0x00FF00FF);
 	SDL_FillRect (surface, NULL, 0x00FF00FF);
 	SDL_Rect dest = {0, 0, 0, 0};
 
@@ -1288,7 +1285,7 @@
 	if (selected)
 	{
 		const SDL_Rect dest = { Sint16 (position.x - 4), Sint16 (position.y - 4), 38, 38};
-		DrawSelectionCorner (buffer, dest, 8, 0x00E0E0E0);
+		DrawSelectionCorner (buffer, dest, 8, 0xFFE0E0E0);
 	}
 
 	switch (displayType)
@@ -1484,7 +1481,7 @@
 
 void cMenuUnitsList::released (void* parent)
 {
-	mouse->GetPos();
+	mouse->updatePos();
 	for (int i = offset; i < offset + maxDisplayUnits; i++)
 	{
 		if (i >= (int) unitsList.size()) break;
@@ -1674,7 +1671,7 @@
 	dest.x += src.w + 3;
 	SDL_Rect mark = { Sint16 (dest.x - src.w / 2), dest.y, 1, src.h };
 
-	SDL_FillRect (buffer, &mark, 0xFC0000);
+	SDL_FillRect (buffer, &mark, 0xFFFC0000);
 
 	if (symType == MENU_SYMBOLS_METAL)
 	{
@@ -1905,11 +1902,11 @@
 	if (drawLines)
 	{
 		SDL_Rect lineRect = { Sint16 (position.x + 2), Sint16 (position.y + 14), 153, 1 };
-		SDL_FillRect (buffer, &lineRect, 0x743904);
+		SDL_FillRect (buffer, &lineRect, 0xFF743904);
 		lineRect.y += 12;
-		SDL_FillRect (buffer, &lineRect, 0x743904);
+		SDL_FillRect (buffer, &lineRect, 0xFF743904);
 		lineRect.y += 12;
-		SDL_FillRect (buffer, &lineRect, 0x743904);
+		SDL_FillRect (buffer, &lineRect, 0xFF743904);
 	}
 	if (unit == NULL) return;
 	const sUnitData* data = &unit->data;
@@ -2127,7 +2124,7 @@
 	const int DETAIL_COLUMN_1 = dest.x + 27;
 	const int DETAIL_COLUMN_2 = dest.x + 42;
 	const int DETAIL_COLUMN_3 = dest.x + 95;
-#define DETAIL_DOLINEBREAK dest.y = y + 14; SDL_FillRect (buffer, &dest, 0xFC0000); y += 19;
+#define DETAIL_DOLINEBREAK dest.y = y + 14; SDL_FillRect (buffer, &dest, 0xFFFC0000); y += 19;
 
 	if (data->canAttack)
 	{
@@ -2349,8 +2346,8 @@
 void cMenuMaterialBar::generateSurface()
 {
 	SDL_Rect src = { 114, 336, position.w, position.h };
-	surface = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xFF00FF);
+	surface = SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (surface, SDL_TRUE, 0xFF00FF);
 	SDL_FillRect (surface, NULL, 0xFF00FF);
 
 	switch (materialType)
@@ -2568,11 +2565,11 @@
 	position.h = src.h;
 	mouseXOff = mouseYOff = 0;
 
-	surface = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, position.w, position.h, Video.getColDepth(), 0, 0, 0, 0);
+	surface = SDL_CreateRGBSurface (0, position.w, position.h, Video.getColDepth(), 0, 0, 0, 0);
 	SDL_FillRect (surface, NULL, 0xFF00FF);
 	if (scrollerType == SCROLLER_TYPE_HUD_ZOOM) SDL_BlitSurface (GraphicsData.gfx_hud_stuff, &src, surface, NULL);
 	else SDL_BlitSurface (GraphicsData.gfx_menu_stuff, &src, surface, NULL);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetColorKey (surface, SDL_TRUE, 0xFF00FF);
 }
 
 void cMenuScroller::draw()
@@ -2663,7 +2660,7 @@
 {
 	SDL_Rect src = { 234, 1, 16, 48};
 	SDL_Rect dest = { 0, 0, 0, 0 };
-	surface = SDL_CreateRGBSurface (Video.getSurfaceType(), 16, position.h - 28, Video.getColDepth(), 0, 0, 0, 0);
+	surface = SDL_CreateRGBSurface (0, 16, position.h - 28, Video.getColDepth(), 0, 0, 0, 0);
 	do
 	{
 		if (position.h - 28 - dest.y < 48) src.h = position.h - 28 - dest.x;
@@ -2961,7 +2958,7 @@
 	}
 }
 
-bool cMenuLineEdit::handleKeyInput (SDL_keysym keysym, const string& ch, void* parent)
+bool cMenuLineEdit::handleKeyInput (const SDL_Keysym& keysym, cMenu* parent)
 {
 	if (readOnly) return false;
 
@@ -2995,28 +2992,7 @@
 			if (wasKeyInput) wasKeyInput (parent);
 			break;
 		default: // no special key - handle as normal character:
-			if (keysym.unicode >= 32)
-			{
-				if (keysym.unicode >= 48 && keysym.unicode <= 57)
-				{
-					if (!takeNumerics) break;
-				}
-				else if (!takeChars) break;
-
-				text.insert (cursorPos, ch);
-				if (cursorPos < (int) text.length()) doPosIncrease (cursorPos, cursorPos);
-				if (cursorPos >= endOffset)
-				{
-					doPosIncrease (endOffset, endOffset);
-					while (font->getTextWide (text.substr (startOffset, endOffset - startOffset), fontType) > position.w - getBorderSize()) doPosIncrease (startOffset, startOffset);
-				}
-				else
-				{
-					if (font->getTextWide (text.substr (startOffset, endOffset - startOffset), fontType) > position.w - getBorderSize()) doPosDecrease (endOffset);
-					else doPosIncrease (endOffset, cursorPos);
-				}
-				if (wasKeyInput) wasKeyInput (parent);
-			}
+			addText (keysym, parent);
 			break;
 	}
 	parentMenu->draw();
@@ -3023,6 +2999,34 @@
 	return true;
 }
 
+void cMenuLineEdit::addText (const SDL_Keysym& keysym, cMenu* parent)
+{
+	if (keysym.sym >= 32)
+	{
+		if (keysym.sym >= 48 && keysym.sym <= 57)
+		{
+			if (!takeNumerics) return;
+		}
+		else if (!takeChars) return;
+
+		std::string ch = cInput::getUTF16Char (keysym.sym);
+
+		text.insert (cursorPos, ch);
+		if (cursorPos < (int) text.length()) doPosIncrease (cursorPos, cursorPos);
+		if (cursorPos >= endOffset)
+		{
+			doPosIncrease (endOffset, endOffset);
+			while (font->getTextWide (text.substr (startOffset, endOffset - startOffset), fontType) > position.w - getBorderSize()) doPosIncrease (startOffset, startOffset);
+		}
+		else
+		{
+			if (font->getTextWide (text.substr (startOffset, endOffset - startOffset), fontType) > position.w - getBorderSize()) doPosDecrease (endOffset);
+			else doPosIncrease (endOffset, cursorPos);
+		}
+		if (wasKeyInput) wasKeyInput (parent);
+	}
+}
+
 void cMenuLineEdit::setReturnPressedFunc (void (*returnPressed_) (void*))
 {
 	returnPressed = returnPressed_;
@@ -3038,9 +3042,9 @@
 {
 	if (Video.getResolutionX() - HUD_TOTAL_WIDTH - 20 < 60) return;
 
-	surface = SDL_CreateRGBSurface (Video.getSurfaceType(), Video.getResolutionX() - HUD_TOTAL_WIDTH - 20, 48, Video.getColDepth(), 0, 0, 0, 0);
+	surface = SDL_CreateRGBSurface (0, Video.getResolutionX() - HUD_TOTAL_WIDTH - 20, 48, Video.getColDepth(), 0, 0, 0, 0);
 	SDL_FillRect (surface, NULL, 0xFF00FF);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetColorKey (surface, SDL_TRUE, 0xFF00FF);
 
 	SDL_Rect src = { 0, 0, 30, 48 };
 	SDL_Rect dest = { 0, 0, 0, 0 };
@@ -3118,14 +3122,14 @@
 {
 	SDL_Rect src = { 10, 0, 10, 10 };
 
-	AutoSurface readySurface (SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
-	SDL_SetColorKey (readySurface, SDL_SRCCOLORKEY, 0xFF00FF);
+	AutoSurface readySurface (SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
+	SDL_SetColorKey (readySurface, SDL_TRUE, 0xFF00FF);
 	SDL_FillRect (readySurface, NULL, 0xFF00FF);
 	SDL_BlitSurface (GraphicsData.gfx_player_ready, &src, readySurface, NULL);
 
 	src.x -= 10;
-	AutoSurface notReadySurface (SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
-	SDL_SetColorKey (notReadySurface, SDL_SRCCOLORKEY, 0xFF00FF);
+	AutoSurface notReadySurface (SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
+	SDL_SetColorKey (notReadySurface, SDL_TRUE, 0xFF00FF);
 	SDL_FillRect (notReadySurface, NULL, 0xFF00FF);
 	SDL_BlitSurface (GraphicsData.gfx_player_ready, &src, notReadySurface, NULL);
 
@@ -3137,7 +3141,7 @@
 			if ( (*players) [i]->isReady()) playerReadys[index]->setImage (readySurface);
 			else playerReadys[index]->setImage (notReadySurface);
 
-			AutoSurface colorSurface (SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
+			AutoSurface colorSurface (SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
 			SDL_BlitSurface ( (*players) [i]->getColorSurface(), &src, colorSurface, NULL);
 			playerColors[index]->setImage (colorSurface);
 
@@ -3420,7 +3424,7 @@
 			position.w = src.w;
 			position.h = src.h;
 
-			surface = SDL_CreateRGBSurface (Video.getSurfaceType(), src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
+			surface = SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0);
 			SDL_BlitSurface (GraphicsData.gfx_menu_stuff, &src, surface, NULL);
 
 			scroller = new cMenuScroller (x - 7, y - 7, cMenuScroller::SCROLLER_TYPE_HORI, this, &scrollerMoved);
@@ -3612,7 +3616,7 @@
 	{
 		const int selIndex = selected - index * maxItems;
 		const SDL_Rect rect = {Sint16 (position.x + 13), Sint16 (position.y + 26 + 55 * selIndex), 38, 38};
-		DrawSelectionCorner (buffer, rect, 8, 0x00E0E0E0);
+		DrawSelectionCorner (buffer, rect, 8, 0xFFE0E0E0);
 	}
 }
 
@@ -3941,7 +3945,7 @@
 		{
 			int selIndex = selected - index * maxItems;
 			const SDL_Rect rect = {Sint16 (position.x + 15), Sint16 (position.y + 23 + 55 * selIndex), 450, 53 };
-			DrawRectangle (buffer, rect, 0x00E0E0E0);
+			DrawRectangle (buffer, rect, 0xFFE0E0E0);
 		}
 	}
 }
@@ -4112,8 +4116,8 @@
 	float zoomFactor = (float) UNIT_IMAGE_SIZE / (unit->data.isBig ? 128.0f : 64.0f);
 	SDL_Rect dest = { 0, 0, 0, 0};
 
-	SDL_Surface* surface = SDL_CreateRGBSurface (SDL_SRCCOLORKEY, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
-	SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_Surface* surface = SDL_CreateRGBSurface (0, UNIT_IMAGE_SIZE, UNIT_IMAGE_SIZE, Video.getColDepth(), 0, 0, 0, 0);
+	SDL_SetColorKey (surface, SDL_TRUE, 0xFF00FF);
 	//SDL_FillRect (surface, NULL, 0xFF00FF);
 
 	if (unit->isABuilding())
Index: menuitems.h
===================================================================
--- menuitems.h	(revision 3446)
+++ menuitems.h	(working copy)
@@ -212,7 +212,7 @@
 	 *@param ch the encoded key
 	 *@param parent pointer to the calling menu
 	 */
-	virtual bool handleKeyInput (SDL_keysym keysym, const std::string& ch, void* parent) { return false; }
+	virtual bool handleKeyInput (const SDL_Keysym& keysym, cMenu* parent) { return false; }
 
 
 	/**
@@ -1028,6 +1028,7 @@
 	bool readOnly;
 	bool takeChars, takeNumerics;
 
+	void addText (const SDL_Keysym& keysym, cMenu* parent);
 	void resetTextPosition();
 	void doPosIncrease (int& value, int pos);
 	void doPosDecrease (int& pos);
@@ -1055,7 +1056,7 @@
 	void setText (const std::string& text_);
 	const std::string& getText() const;
 	void setSize (int w, int h);
-	virtual bool handleKeyInput (SDL_keysym keysym, const std::string& ch, void* parent);
+	virtual bool handleKeyInput (const SDL_Keysym& keysym, cMenu* parent);
 
 	void setReturnPressedFunc (void (*returnPressed_) (void*));
 };
Index: menus.cpp
===================================================================
--- menus.cpp	(revision 3450)
+++ menus.cpp	(working copy)
@@ -234,7 +234,6 @@
 	end = false;
 	terminate = false;
 	activeItem = NULL;
-	drawnEveryFrame = false;
 
 	lastScreenResX = Video.getResolutionX();
 	lastScreenResY = Video.getResolutionY();
@@ -292,10 +291,13 @@
 		case MNU_BG_BLACK:
 			// fill the whole screen with black to prevent
 			// old garbage from menus that don't support resolutions > 640x480
-			SDL_FillRect (buffer, NULL, 0x000000);
+			SDL_FillRect (buffer, NULL, 0xFF000000);
 			break;
 		case MNU_BG_ALPHA:
-			if (cSettings::getInstance().isAlphaEffects() && firstDraw) SDL_BlitSurface (GraphicsData.gfx_shadow, NULL, buffer, NULL);
+			if (cSettings::getInstance().isAlphaEffects() && firstDraw)
+				SDL_BlitSurface (GraphicsData.gfx_shadow, NULL, buffer, NULL);
+			else
+				SDL_FillRect (buffer, NULL, SDL_MapRGBA (buffer->format, 0, 0, 0, 0));
 			break;
 		case MNU_BG_TRANSPARENT:
 			// do nothing here
@@ -318,9 +320,7 @@
 
 	if (showScreen)
 	{
-		if (drawnEveryFrame) mouse->draw (true, buffer);
 		Video.draw();
-		if (!drawnEveryFrame) mouse->draw (false, screen);
 	}
 }
 
@@ -327,8 +327,6 @@
 //------------------------------------------------------------------------------
 int cMenu::show (cClient* client)
 {
-	drawnEveryFrame = false;
-
 	mouse->SetCursor (CHand);
 	draw (true);
 
@@ -357,11 +355,9 @@
 			lastResY = Video.getResolutionY();
 		}
 
-		mouse->GetPos();
+		mouse->updatePos();
 		if (mouse->moved())
 		{
-			mouse->draw (true, screen);
-
 			for (unsigned int i = 0; i < menuItems.size(); i++)
 			{
 				cMenuItem* menuItem = menuItems[i];
@@ -406,7 +402,7 @@
 //------------------------------------------------------------------------------
 void cMenu::handleMouseInput (sMouseState mouseState)
 {
-	mouse->GetPos();
+	mouse->updatePos();
 	mouse->isDoubleClick = mouseState.isDoubleClick;
 
 	for (size_t i = 0; i != menuItems.size(); ++i)
@@ -434,9 +430,9 @@
 }
 
 //------------------------------------------------------------------------------
-void cMenu::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cMenu::handleKeyInput (const SDL_KeyboardEvent& key)
 {
-	if (activeItem && key.state == SDL_PRESSED) activeItem->handleKeyInput (key.keysym, ch, this);
+	if (activeItem && key.state == SDL_PRESSED) activeItem->handleKeyInput (key.keysym, this);
 }
 
 //------------------------------------------------------------------------------
@@ -539,7 +535,6 @@
 	menu->infoImage->setImage (surface);
 	menu->infoImage->draw();
 	Video.draw();
-	mouse->draw (false, screen);
 }
 
 //------------------------------------------------------------------------------
@@ -1312,7 +1307,7 @@
 			const int MAPWINSIZE = 112;
 			const int SELECTED = 0x00C000;
 			const int UNSELECTED = 0x000000;
-			AutoSurface imageSurface (SDL_CreateRGBSurface (Video.getSurfaceType(), MAPWINSIZE + 8, MAPWINSIZE + 8, Video.getColDepth(), 0, 0, 0, 0));
+			AutoSurface imageSurface (SDL_CreateRGBSurface (0, MAPWINSIZE + 8, MAPWINSIZE + 8, Video.getColDepth(), 0, 0, 0, 0));
 
 			if (selectedMapIndex == i + offset)
 			{
@@ -1461,7 +1456,7 @@
 			yCount = 1;
 		}
 		SDL_Surface* img = LoadPCX (clanLogoPaths[i].c_str());
-		SDL_SetColorKey (img, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (img, SDL_TRUE, 0xFF00FF);
 		clanImages[i] = new cMenuImage (position.x + 88 + xCount * 154 - (img ? (img->w / 2) : 0), position.y + 48 + yCount * 150, img);
 		clanImages[i]->setReleasedFunction (&clanSelected);
 		menuItems.push_back (clanImages[i]);
@@ -2215,9 +2210,9 @@
 	menu->landData.landingState = LANDING_POSITION_OK;
 	menu->backButton->setLocked (true);
 	{
-		AutoSurface circleSurface (SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, Video.getResolutionX() - 192, Video.getResolutionY() - 32, Video.getColDepth(), 0, 0, 0, 0));
+		AutoSurface circleSurface (SDL_CreateRGBSurface (0, Video.getResolutionX() - 192, Video.getResolutionY() - 32, Video.getColDepth(), 0, 0, 0, 0));
 		SDL_FillRect (circleSurface, NULL, 0xFF00FF);
-		SDL_SetColorKey (circleSurface, SDL_SRCCOLORKEY, 0xFF00FF);
+		SDL_SetColorKey (circleSurface, SDL_TRUE, 0xFF00FF);
 
 		int posX = (int) (menu->landData.iLandX * fakx);
 		int posY = (int) (menu->landData.iLandY * faky);
@@ -2231,7 +2226,6 @@
 
 	Video.draw();
 	mouse->SetCursor (CHand);
-	mouse->draw (false, screen);
 
 	menu->hitPosition();
 }
@@ -2251,7 +2245,7 @@
 }
 
 //------------------------------------------------------------------------------
-void cLandingMenu::handleKeyInput (SDL_KeyboardEvent& key, const string& ch)
+void cLandingMenu::handleKeyInput (const SDL_KeyboardEvent& key)
 {
 	if (key.keysym.sym == SDLK_ESCAPE && key.state == SDL_PRESSED)
 	{
@@ -2610,7 +2604,7 @@
 void cNetworkMenu::setColor (int color)
 {
 	SDL_Rect src = { 0, 0, 83, 10 };
-	AutoSurface colorSurface (SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
+	AutoSurface colorSurface (SDL_CreateRGBSurface (0, src.w, src.h, Video.getColDepth(), 0, 0, 0, 0));
 	SDL_BlitSurface (OtherData.colors[color], &src, colorSurface, NULL);
 	colorImage->setImage (colorSurface);
 }
@@ -4608,7 +4602,7 @@
 				upgradeButtons[pos]->setLocked (true);
 			}
 
-			SDL_Surface* surface = SDL_CreateRGBSurface (Video.getSurfaceType(), srcSurface->w, srcSurface->h, Video.getColDepth(), 0, 0, 0, 0);
+			SDL_Surface* surface = SDL_CreateRGBSurface (0, srcSurface->w, srcSurface->h, Video.getColDepth(), 0, 0, 0, 0);
 			SDL_BlitSurface (srcSurface, NULL, surface, NULL);
 			unitImages[pos]->setImage (surface);
 
Index: menus.h
===================================================================
--- menus.h	(revision 3446)
+++ menus.h	(working copy)
@@ -192,7 +192,6 @@
 class cMenu
 {
 protected:
-	bool drawnEveryFrame;
 	/** When this is true the show-loop will be end and give 0 as return.
 	 * Should be used when the menu is closed by ok or done.
 	 */
@@ -276,7 +275,7 @@
 	 * delegates the keyinput to the active menuitem.
 	 *@author alzi
 	 */
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 
 	/**
 	 * sends a netmessage to the given player.
@@ -657,7 +656,7 @@
 	cLandingMenu (cClient& client_, cStaticMap& map_);
 
 private:
-	virtual void handleKeyInput (SDL_KeyboardEvent& key, const std::string& ch);
+	virtual void handleKeyInput (const SDL_KeyboardEvent& key);
 	virtual void handleNetMessages();
 
 	void handleNetMessage (cNetMessage* message);
Index: mouse.cpp
===================================================================
--- mouse.cpp	(revision 3442)
+++ mouse.cpp	(working copy)
@@ -16,68 +16,33 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
+
 #include "mouse.h"
+
 #include "main.h"
 #include "client.h"
 #include "settings.h"
 #include "hud.h"
 
+#include <SDL.h>
 
-cMouse::cMouse()
+cMouse::cMouse() : sdlCursor (NULL)
 {
-	visible = false;
 	cur = NULL;
-	LastX = -100;
-	LastY = -100;
 	x = 0;
 	y = 0;
 	isDoubleClick = false;
-	prevScreenX = 0;
-	prevScreenY = 0;
-
-	DrawX = 0;
-	DrawY = 0;
 }
 
-// Malt die Maus, und wenn draw_back gesetzt ist, auch den alten Hintergrund:
-void cMouse::draw (bool draw_back, SDL_Surface* sf)
+cMouse::~cMouse()
 {
-	if (!visible || cur == NULL) return;
-	GetPos();
-
-	// restore old background
-	if (back && draw_back && LastX != -100)
-	{
-		SDL_Rect dest;
-		dest.x = LastX;
-		dest.y = LastY;
-		SDL_BlitSurface (back, NULL, sf, &dest);
-
-		SDL_UpdateRect (sf, dest.x, dest.y, dest.w, dest.h);
-	}
-
-	//change size of back surface if necessary, e.g. when the mouse cursor has changed
-	if (!back || back->h != cur->h || back->w != cur->w)
-	{
-		back = SDL_CreateRGBSurface (Video.getSurfaceType(), cur->w, cur->h, 32, 0, 0, 0, 0);
-	}
-
-	// store new background
-	GetBack (sf);
-	SDL_Rect dest;
-	dest.x = DrawX;
-	dest.y = DrawY;
-	LastX = DrawX;
-	LastY = DrawY;
-
-	//draw mouse
-	SDL_BlitSurface (cur, NULL, sf, &dest);
-	SDL_UpdateRect (sf, dest.x, dest.y, dest.w, dest.h);
+	if (sdlCursor) SDL_FreeCursor (sdlCursor);
 }
 
 bool cMouse::SetCursor (eCursor const typ)
 {
 	const SDL_Surface* const lastCur = cur;
+
 	switch (typ)
 	{
 		default:
@@ -106,56 +71,50 @@
 		case CDisable:   cur = GraphicsData.gfx_Cdisable;    break;
 		case CActivate:  cur = GraphicsData.gfx_Cactivate;   break;
 	}
-	return lastCur != cur;
+	if (lastCur == cur)
+	{
+		return false;
+	}
+	if (sdlCursor) SDL_FreeCursor (sdlCursor);
+	int hotx = 0;
+	int hoty = 0;
+	getCursorOffset (hotx, hoty);
+	sdlCursor = SDL_CreateColorCursor (cur, hotx, hoty);
+	SDL_SetCursor (sdlCursor);
+	return true;
 }
 
-// Liest den Hintergrund in das Back-Surface ein:
-void cMouse::GetBack (SDL_Surface* sf)
-{
-	SDL_Rect scr;
-	GetPos();
-	scr.x = DrawX;
-	scr.y = DrawY;
-	scr.w = back->w;
-	scr.h = back->h;
-	SDL_BlitSurface (sf, &scr, back, NULL);
-}
-
-void cMouse::restoreBack (SDL_Surface* sf)
-{
-	SDL_Rect dest;
-	dest.x = LastX;
-	dest.y = LastY;
-	SDL_BlitSurface (back, NULL, sf, &dest);
-}
-
 //updates the internal mouse position
-void cMouse::GetPos()
+void cMouse::updatePos()
 {
 	SDL_GetMouseState (&x, &y);
-
-	// Cursor Offset bestimmen:
-	int offX;
-	int offY;
-
-	getCursorOffset (offX, offY);
-
-	DrawX = x + offX;
-	DrawY = y + offY;
 }
 
 // gets the cursor offset. transforms screenspace to clickspace
 void cMouse::getCursorOffset (int& x, int& y) const
 {
-	if (cur == GraphicsData.gfx_Cselect || cur == GraphicsData.gfx_Chelp || cur == GraphicsData.gfx_Cmove || cur == GraphicsData.gfx_Cmove_draft || cur == GraphicsData.gfx_Cno || cur == GraphicsData.gfx_Ctransf || cur == GraphicsData.gfx_Cband || cur == GraphicsData.gfx_Cload || cur == GraphicsData.gfx_Cmuni || cur == GraphicsData.gfx_Crepair || cur == GraphicsData.gfx_Cactivate)
+	if (cur == GraphicsData.gfx_Cselect
+		|| cur == GraphicsData.gfx_Chelp
+		|| cur == GraphicsData.gfx_Cmove
+		|| cur == GraphicsData.gfx_Cmove_draft
+		|| cur == GraphicsData.gfx_Cno
+		|| cur == GraphicsData.gfx_Ctransf
+		|| cur == GraphicsData.gfx_Cband
+		|| cur == GraphicsData.gfx_Cload
+		|| cur == GraphicsData.gfx_Cmuni
+		|| cur == GraphicsData.gfx_Crepair
+		|| cur == GraphicsData.gfx_Cactivate)
 	{
-		x = -12;
-		y = -12;
+		x = 12;
+		y = 12;
 	}
-	else if (cur == GraphicsData.gfx_Cattack || cur == GraphicsData.gfx_Csteal || cur == GraphicsData.gfx_Cdisable || cur == GraphicsData.gfx_Cattackoor)
+	else if (cur == GraphicsData.gfx_Cattack
+			 || cur == GraphicsData.gfx_Csteal
+			 || cur == GraphicsData.gfx_Cdisable
+			 || cur == GraphicsData.gfx_Cattackoor)
 	{
-		x = -19;
-		y = -16;
+		x = 19;
+		y = 16;
 	}
 	else
 	{
@@ -175,6 +134,16 @@
 	return moved;
 }
 
+void cMouse::Show()
+{
+	SDL_ShowCursor (true);
+}
+
+void cMouse::Hide()
+{
+	SDL_ShowCursor (false);
+}
+
 // Liefert die Koordinaten der Kachel unter der Maus:
 int cMouse::getKachelX (const cGameGUI& gameGUI) const
 {
Index: mouse.h
===================================================================
--- mouse.h	(revision 3442)
+++ mouse.h	(working copy)
@@ -19,12 +19,13 @@
 #ifndef mouseH
 #define mouseH
 
-#include "autosurface.h"
 #include "defines.h"
-#include <SDL.h>
 
 class cGameGUI;
+struct SDL_Surface;
+struct SDL_Cursor;
 
+
 // Die Mauszeigertypen ///////////////////////////////////////////////////////
 enum eCursor {CHand, CNo, CSelect, CMove, CPfeil1, CPfeil2, CPfeil3, CPfeil4, CPfeil6, CPfeil7, CPfeil8, CPfeil9, CHelp, CAttack, CBand, CTransf, CLoad, CMuni, CRepair, CSteal, CDisable, CActivate, CMoveDraft, CAttackOOR};
 
@@ -33,22 +34,16 @@
 {
 public:
 	cMouse();
+	~cMouse();
 
-	void draw (bool draw_back, SDL_Surface* sf);
-
 	// Set a new cursor.
 	bool SetCursor (eCursor);
 
-	void GetBack (SDL_Surface* sf);
-	/**
-	* Draws the currently stored background to sf
-	*/
-	void restoreBack (SDL_Surface* sf);
-	void GetPos();
+	void updatePos();
 	void getCursorOffset (int& x, int& y) const;
 	bool moved();
-	void Show() {LastX = -100; visible = true;}
-	void Hide() {visible = false;}
+	void Show();
+	void Hide();
 	/**
 	* return the X Coordinate of the Cursor on the map
 	*/
@@ -57,19 +52,14 @@
 	* return the Y Coordinate of the Cursor on the map
 	*/
 	int getKachelY (const cGameGUI& gameGUI) const;
-private:
-	bool visible; // Gibt an, ob die Maus angezeigt werden soll.
+
 public:
 	SDL_Surface* cur; // Current Cursor.
 private:
-	AutoSurface back; // Zum Speichern des Maushintergrundes.
+	SDL_Cursor* sdlCursor;
 public:
 	int x, y; /** the pixel position of the cursor on the map */
 	bool isDoubleClick;
-private:
-	int prevScreenX, prevScreenY;
-	int LastX, LastY; // Die letzte Position der Maus.
-	int DrawX, DrawY; // Die Position, an die die Maus gezeichnet werden soll.
 };
 
 // Die Maus //////////////////////////////////////////////////////////////////
Index: mveplayer.cpp
===================================================================
--- mveplayer.cpp	(revision 3442)
+++ mveplayer.cpp	(working copy)
@@ -24,18 +24,19 @@
 /*	MVEPlayer.c - Plays 8-bit Interplay MVE multimedia files.
 	Author: jarli
 */
-#include "autosurface.h"
+
 #include "mveplayer.h"
-#include <assert.h>
+
 #include "main.h"
+#include "autoptr.h"
+#include "autosurface.h"
 #include "video.h"
 
-#ifdef _MSC_VER
 #include <SDL.h>
-#else
-#include <SDL.h>
-#endif
 
+#include <cassert>
+#include <vector>
+
 /* define (potentially) handled opcode types */
 #define STOP_PLAYBACK			0x00
 #define FETCH_NEXT_CHUNK		0x01
@@ -50,6 +51,13 @@
 #define SET_DECODING_MAP		0x0F
 #define VIDEO_DATA				0x11
 
+#if 1 // TODO: [SDL2]: SDL_SetColors
+inline void SDL_SetColors(SDL_Surface* surface, SDL_Color* colors, int index, int size)
+{
+	SDL_SetPaletteColors(surface->format->palette, colors, index, size);
+}
+#endif
+
 /**************************/
 /* internally used macros */
 /**************************/
@@ -61,24 +69,23 @@
 /* internally used structures */
 /******************************/
 
-typedef struct CHUNK
+struct chunk
 {
 	Uint16 length;
 	Uint16 type;
-} chunk;
+};
 
-typedef struct OPCODE
+struct opcode
 {
 	Uint16 length;
 	Uint8 type;
 	Uint8 version;
-} opcode;
+};
 
-typedef struct BUFSTRUCT
+struct mvebuffer
 {
-	Uint32 length;
-	Uint8* data;
-} mvebuffer;
+	std::vector<Uint8> data;
+};
 
 /********************/
 /* global variables */
@@ -85,19 +92,26 @@
 /********************/
 
 /* flow control flags */
-Uint8 QUITTING = 0, PAUSED = 0;
+static Uint8 QUITTING = 0;
+static Uint8 PAUSED = 0;
 
 /* timer flags */
-Uint8 TIMER_CREATED	= 0, TIMER_INIT = 0;
+static Uint8 TIMER_CREATED = 0;
+static Uint8 TIMER_INIT = 0;
 
 /* audio flags */
-Uint8 AUDIO_PLAYING = 0, AUDIO_COMPRESSED = 0, AUDIO_STEREO = 0, SAMPLESIZE16 = 0;
+static Uint8 AUDIO_PLAYING = 0;
+static Uint8 AUDIO_COMPRESSED = 0;
+static Uint8 AUDIO_STEREO = 0;
+static Uint8 SAMPLESIZE16 = 0;
 
 /* screen mvebuffers */
-Uint8* v_backbuf = NULL, *frame_hot = NULL, *frame_cold = NULL;
+static std::vector<Uint8> v_backbuf;
+static Uint8* frame_hot = NULL;
+static Uint8* frame_cold = NULL;
 
 /* target time between frames */
-float ms_per_frame = 0;
+static float ms_per_frame = 0;
 
 /***********************/
 /* function prototypes */
@@ -125,22 +139,24 @@
 	char fileTestString[26];
 
 	/* timer vars */
-	Uint32 timer_rate = 0, current_time = 0;
-	Uint16 timer_subdivision = 0;
+	Uint32 current_time = 0;
 	float start_time = 0;
 
 	/* audio variables */
-	SDL_AudioSpec* desired = NULL;
+	AutoPtr<SDL_AudioSpec> desired;
 	Uint16 file_audio_flags = 0;
-	mvebuffer audio_mvebuffer, audio_data_read, temp_audio_mvebuffer;
+	mvebuffer audio_mvebuffer;
+	mvebuffer audio_data_read;
 
 	/* video variables */
 	Uint32 screen_mvebuffer_size = 0;
-	Uint16 width_blocks = 0, height_blocks = 0;
-	Uint8* map = NULL, *video = NULL, *temp = NULL;
-	SDL_Surface* screen = NULL;
-	SDL_Rect movie_screen;
-	const SDL_VideoInfo* initial_vid_state;
+	Uint16 width_blocks = 0;
+	Uint16 height_blocks = 0;
+	std::vector<Uint8> map;
+	std::vector<Uint8> video;
+	SDL_Window* sdlWindow = NULL;
+	SDL_Renderer* sdlRenderer = NULL;
+	SDL_Texture* sdlTexture = NULL;
 
 	/* file handle */
 	SDL_RWops* mve = NULL;
@@ -149,17 +165,6 @@
 	chunk ch;
 	opcode op;
 
-	/* a counting var */
-	Uint16 i = 0;
-
-	/* initialize audio mvebuffers */
-	audio_mvebuffer.data = NULL;
-	audio_mvebuffer.length = 0;
-	audio_data_read.data = NULL;
-	audio_data_read.length = 0;
-	temp_audio_mvebuffer.data = NULL;
-	temp_audio_mvebuffer.length = 0;
-
 	/******************************************/
 	/* validate MVE, init SDL, and begin read */
 	/******************************************/
@@ -172,7 +177,7 @@
 		return UNABLE_TO_OPEN_FILE;
 
 	/* read the first 26 bytes */
-	if (SDL_RWread (mve, fileTestString, sizeof (char), idlen) < 0)
+	if (!SDL_RWread (mve, fileTestString, sizeof (char), idlen))
 		return FILE_TOO_SHORT;
 
 	/* validate MVE idstring */
@@ -191,10 +196,6 @@
 	if (op.type > 0x15 || op.version > 3)
 		return MVE_CORRUPT;
 
-	//set window to center of screen
-	static char cVideoPos[] = "SDL_VIDEO_CENTERED=1";
-	putenv (cVideoPos);
-
 	/* See if SDL is already initialized by MAXR main (audio shouldn't be) */
 	if (audio)
 	{
@@ -209,10 +210,6 @@
 		if (SDL_WasInit (SDL_INIT_VIDEO | SDL_INIT_TIMER) != (SDL_INIT_VIDEO | SDL_INIT_TIMER))
 			return SDL_INIT_FAILURE;
 
-	/* save initial video state; we'll restore at the end */
-	if (!fullscreen)
-		initial_vid_state = SDL_GetVideoInfo();
-
 	// hide mouse in fullscreen
 	if (fullscreen)
 		SDL_ShowCursor (SDL_DISABLE);
@@ -241,35 +238,33 @@
 		switch (op.type)
 		{
 			case STOP_PLAYBACK:
-
+			{
 				QUITTING = !QUITTING;
-
 				break;
-
+			}
 			case FETCH_NEXT_CHUNK:
-
+			{
 				if (!SDL_RWread (mve, &ch, sizeof (ch), 1))
 					return CHUNK_READ_FAILED;
-
 				break;
-
+			}
 			case CREATE_TIMER:
-
+			{
 				/* get timer rate (uint32) */
-				timer_rate = SDL_ReadLE32 (mve);
+				const Uint32 timer_rate = SDL_ReadLE32 (mve);
 
 				/* get timer subdivision (uint16) */
-				timer_subdivision = SDL_ReadLE16 (mve);
+				const Uint16 timer_subdivision = SDL_ReadLE16 (mve);
 
-				ms_per_frame = (float) (timer_rate * timer_subdivision / 1000.0);
+				ms_per_frame = timer_rate * timer_subdivision / 1000.0f;
 
 				TIMER_CREATED = 1;
 				TIMER_INIT = 1;
 
 				break;
-
+			}
 			case INIT_AUDIO_BUFFERS:
-
+			{
 				if (!audio)
 				{
 					/* strip opcode data; don't know how to catch errors here */
@@ -277,9 +272,8 @@
 					break;
 				}
 
-
 				/* init sdl audio settings */
-				desired = (SDL_AudioSpec*) malloc (sizeof (SDL_AudioSpec));
+				desired = new SDL_AudioSpec;
 
 				/* strip the unknown word out */
 				SDL_ReadLE16 (mve);
@@ -315,8 +309,10 @@
 				if (op.version == 1)
 					AUDIO_COMPRESSED = (file_audio_flags & 0x04 ? 1 : 0);
 
-				/* we're going to abort if is compressed and (not stereo or not AUDIO_S16) because we don't know what to do */
-				/* besides, we've never seen such an MVE before... */
+				// we're going to abort if is compressed
+				// and (not stereo or not AUDIO_S16)
+				// because we don't know what to do
+				// besides, we've never seen such an MVE before...
 				if (AUDIO_COMPRESSED && (!AUDIO_STEREO || !SAMPLESIZE16))
 					return CANNOT_PROCESS_AUDIO;
 
@@ -327,9 +323,9 @@
 					SDL_ReadLE16 (mve);
 
 				break;
-
+			}
 			case START_AUDIO:
-
+			{
 				if (!audio)
 					break;
 
@@ -339,15 +335,16 @@
 					SDL_PauseAudio (0);
 				}
 				break;
-
+			}
 			case INIT_VIDEO_BUFFERS:
-
-				/* get the requested dimensions
-				note: this is in 8x8 pixel chunks so multiply by 8 to get requested screen pixels*/
+			{
+				// get the requested dimensions
+				// note: this is in 8x8 pixel chunks
+				// so multiply by 8 to get requested screen pixels
 				width_blocks = SDL_ReadLE16 (mve);
 				height_blocks = SDL_ReadLE16 (mve);
 
-				/* ditch the rest of the opcode data*/
+				// ditch the rest of the opcode data
 				if (op.version > 0)
 				{
 					SDL_ReadLE16 (mve);
@@ -362,63 +359,56 @@
 				}
 
 				/* initialize video mvebuffer to the actual movie dimensions */
-				frame_buf = SDL_CreateRGBSurface (Video.getSurfaceType(), width_blocks << 3, height_blocks << 3, 8, 0, 0, 0, 0);
+				frame_buf = SDL_CreateRGBSurface (0, width_blocks << 3, height_blocks << 3, 8, 0, 0, 0, 0);
 
 				/* init movie screen rect for fullscreen purposes */
-				movie_screen.x = (screen->w - frame_buf->w) >> 1;
-				movie_screen.y = (screen->h - frame_buf->h) >> 1;
+				//movie_screen.x = (screen->w - frame_buf->w) >> 1;
+				//movie_screen.y = (screen->h - frame_buf->h) >> 1;
 
-				/* erase old video backmvebuffer */
-				free (v_backbuf);
-
-				/* allocate memory for the backmvebuffers sufficient for the screen pixel mvebuffer */
+				// allocate memory for the backmvebuffers sufficient
+				// for the screen pixel mvebuffer
 				screen_mvebuffer_size = frame_buf->h * frame_buf->w;
 
-				v_backbuf = (Uint8*) calloc (1, screen_mvebuffer_size << 1);
-				assert (v_backbuf);
+				v_backbuf.resize (screen_mvebuffer_size << 1);
 
-				frame_hot = v_backbuf;
-				frame_cold = v_backbuf + screen_mvebuffer_size;
+				frame_hot = v_backbuf.data();
+				frame_cold = v_backbuf.data() + screen_mvebuffer_size;
 
 				break;
-
+			}
 			case SEND_BUFFER_TO_DISPLAY:
-
+			{
 				/* write the decoded data to the frame_buf */
 				memcpy (frame_buf->pixels, frame_hot, screen_mvebuffer_size);
 
-				/* send the mvebuffer to the screen mvebuffer */
-				if (SDL_MUSTLOCK (screen))
-					SDL_LockSurface (screen);
+				// TODO: [SDL2] replace SDL_CreateTextureFromSurface ?
+				sdlTexture = SDL_CreateTextureFromSurface(sdlRenderer, frame_buf);
+				//SDL_UpdateTexture(sdlTexture, NULL, frame_buf->pixels, frame_buf->pitch);
 
-				if (fullscreen)
-					SDL_SoftStretch (frame_buf, NULL, screen, NULL);
-				else
-					SDL_BlitSurface (frame_buf, NULL, screen, &movie_screen);
+				SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, NULL);
 
-				if (SDL_MUSTLOCK (screen))
-					SDL_UnlockSurface (screen);
-
-				/* increment start time - this is now our target frame output time */
+				// increment start time
+				// this is now our target frame output time
 				start_time += ms_per_frame;
 
 				/* what time is it now? */
 				current_time = SDL_GetTicks();
 
-				/* if there's time to next scheduled update, force delay to our target output time */
+				// if there's time to next scheduled update,
+				// force delay to our target output time
 				if (current_time < start_time)
 					SDL_Delay ( (Uint32) (start_time - current_time));
 
 				/* update the screen */
-				SDL_UpdateRect (screen, 0, 0, 0, 0);
+				SDL_RenderPresent(sdlRenderer);
 
 				/* strip opcode data; don't know how to catch errors here */
 				mve->seek (mve, op.length, SEEK_CUR);
 
 				break;
-
+			}
 			case AUDIO_FRAME:
-
+			{
 				if (!audio)
 				{
 					/* strip opcode data; don't know how to catch errors here */
@@ -430,18 +420,22 @@
 				SDL_ReadLE16 (mve);
 				SDL_ReadLE16 (mve);
 
-				/* lock SDL out of the audio_mvebuffer; we'll release at the end */
+				// lock SDL out of the audio_mvebuffer;
+				// we'll release at the end
 				SDL_LockAudio();
 
 				if (AUDIO_COMPRESSED)
 				{
-					/* send in the raw data via audio_data_read; it will be returned the same way */
-					/* read in the compressed data (should be op.length - 4 [the 4 being seq-index and stream-mask]) */
-					audio_data_read.length =  op.length - 4;
-					audio_data_read.data = (Uint8*) malloc (audio_data_read.length);
-					assert (audio_data_read.data != NULL);
+					// send in the raw data via audio_data_read;
+					// it will be returned the same way
 
-					if (SDL_RWread (mve, audio_data_read.data, audio_data_read.length, 1) < 0)
+					// read in the compressed data
+					// (should be op.length - 4
+					//  [the 4 being seq-index and stream-mask])
+					const Uint32 length = op.length - 4;
+					audio_data_read.data.resize(length);
+
+					if (!SDL_RWread (mve, audio_data_read.data.data(), length, 1))
 						return AUDIO_FRAME_READ_FAILURE;
 					MVEPlayerDecodeAudio (&audio_data_read);
 				}
@@ -448,84 +442,96 @@
 				else
 				{
 					/* get the stream length */
-					audio_data_read.length = SDL_ReadLE16 (mve);
+					const Uint32 length = SDL_ReadLE16 (mve);
 
 					/* allocate memory sufficient for the data read */
-					audio_data_read.data = (Uint8*) malloc (audio_data_read.length);
-					assert (audio_data_read.data != NULL);
+					audio_data_read.data.resize (length);
 
 					/* get audio data */
-					if (SDL_RWread (mve, audio_data_read.data, audio_data_read.length, 1) < 0)
+					if (!SDL_RWread (mve, audio_data_read.data.data(), length, 1))
 						return AUDIO_FRAME_READ_FAILURE;
 				}
-				/* at this point, we have uncompressed audio in audio_data_read, along with appropriate lengths */
+				// at this point, we have uncompressed audio in audio_data_read,
+				// along with appropriate lengths
 
-				/* create temp_audio_mvebuffer the size of old audio mvebuffer + new audio data */
-				temp_audio_mvebuffer.length = audio_data_read.length + audio_mvebuffer.length;
-				temp_audio_mvebuffer.data = (Uint8*) malloc (temp_audio_mvebuffer.length);
-				assert (temp_audio_mvebuffer.data != NULL);
+				// create temp_audio_mvebuffer
+				// the size of old audio mvebuffer + new audio data
+				mvebuffer temp_audio_mvebuffer;
+				temp_audio_mvebuffer.data.resize (audio_data_read.data.size() + audio_mvebuffer.data.size());
 
 				/* copy old audio mvebuffer to temp_audio_mvebuffer */
-				memcpy (temp_audio_mvebuffer.data, audio_mvebuffer.data, audio_mvebuffer.length);
+				std::copy(audio_mvebuffer.data.begin(), audio_mvebuffer.data.end(),
+						  temp_audio_mvebuffer.data.begin());
 
 				/* append new data to temp_audio_mvebuffer */
-				memcpy (temp_audio_mvebuffer.data + audio_mvebuffer.length, audio_data_read.data, audio_data_read.length);
+				std::copy (audio_data_read.data.begin(), audio_data_read.data.end(),
+						   temp_audio_mvebuffer.data.begin() + audio_mvebuffer.data.size());
 
-				/* free audio mvebuffer */
-				free (audio_mvebuffer.data);
-
-				/* temp_audio_mvebuffer has the requested data, and audio_mvebuffer needs to have it. */
+				// temp_audio_mvebuffer has the requested data,
+				// and audio_mvebuffer needs to have it.
 				audio_mvebuffer.data = temp_audio_mvebuffer.data;
-				audio_mvebuffer.length = temp_audio_mvebuffer.length;
 
 				/* let SDL have access to the audio_mvebuffer */
 				SDL_UnlockAudio();
 
 				/* close off temp_audio_mvebuffer */
-				temp_audio_mvebuffer.data = NULL;
-				temp_audio_mvebuffer.length = 0;
+				temp_audio_mvebuffer.data.clear();
 
 				/* close off audio_data_read */
-				free (audio_data_read.data);
-				audio_data_read.data = NULL;
-				audio_data_read.length = 0;
+				audio_data_read.data.clear();
 
 				break;
-
+			}
 			case INIT_VIDEO_MODE:
-				/* Skip unused width and height. */
-				SDL_ReadLE16 (mve);
-				SDL_ReadLE16 (mve);
+			{
+				/*const Uint16 width =*/ SDL_ReadLE16 (mve);
+				/*onst Uint16 height =*/ SDL_ReadLE16 (mve);
 
 				/* if we've been here before */
-				if (screen)
-					SDL_FreeSurface (screen);
+				if (sdlTexture) SDL_DestroyTexture (sdlTexture);
+				if (sdlRenderer) SDL_DestroyRenderer (sdlRenderer);
+				if (sdlWindow) SDL_DestroyWindow (sdlWindow);
 
 				if (fullscreen)
-					screen = SDL_SetVideoMode (dwidth, dheight, 8, Video.getSurfaceType() | SDL_FULLSCREEN);
+				{
+					sdlWindow = SDL_CreateWindow("Video",
+												 SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+												 0, 0,
+												 SDL_WINDOW_OPENGL | SDL_WINDOW_FULLSCREEN_DESKTOP);
+				}
 				else
-					screen = SDL_SetVideoMode (dwidth, dheight, 8, Video.getSurfaceType());
+				{
+					sdlWindow = SDL_CreateWindow("Video",
+												 SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+												 dwidth, dheight,
+												 SDL_WINDOW_OPENGL);
+					SDL_SetWindowIcon (sdlWindow, AutoSurface (SDL_LoadBMP (MAXR_ICON)));
+				}
+				sdlRenderer = SDL_CreateRenderer(sdlWindow, -1, 0);
+				//sdlTexture = SDL_CreateTexture(sdlRenderer,
+				//							   SDL_PIXELFORMAT_INDEX4MSB,
+				//							   SDL_TEXTUREACCESS_STREAMING,
+				//							   width, height);
 
-				//SDL_WM_SetCaption(filename, NULL);
-
 				/* strip unknown flag word */
 				SDL_ReadLE16 (mve);
 
 				break;
-
+			}
 			case SET_PALETTE:
 			{
-				Uint8 r = 0, g = 0, b = 0;
-				Uint16 palette_start = 0, numPalColors = 0;
+				Uint8 r = 0;
+				Uint8 g = 0;
+				Uint8 b = 0;
 
 				/* get # of first entry to fill */
-				palette_start = SDL_ReadLE16 (mve);
+				const Uint16 palette_start = SDL_ReadLE16 (mve);
 
 				/* get number of entries in palette */
-				numPalColors = SDL_ReadLE16 (mve);
+				const Uint16 numPalColors = SDL_ReadLE16 (mve);
 
 				/* fill the palette */
-				for (i = 0; i < 256; i++)
+				for (int i = 0; i < 256; i++)
 				{
 					if (i < palette_start)
 					{
@@ -540,7 +546,8 @@
 						SDL_RWread (mve, &r, sizeof (Uint8), 1);
 						SDL_RWread (mve, &g, sizeof (Uint8), 1);
 						SDL_RWread (mve, &b, sizeof (Uint8), 1);
-						/* interplay divides the palette entries by 4; must multiply by 4. */
+						// interplay divides the palette entries by 4;
+						// must multiply by 4.
 						r <<= 2;
 						g <<= 2;
 						b <<= 2;
@@ -548,51 +555,38 @@
 					frame_buf->format->palette->colors[i].r = r;
 					frame_buf->format->palette->colors[i].g = g;
 					frame_buf->format->palette->colors[i].b = b;
-					frame_buf->format->palette->colors[i].unused = 0;
+					frame_buf->format->palette->colors[i].a = 255;
 				}
 
 				/* install the palette in the screen surface */
-				SDL_SetColors (screen, frame_buf->format->palette->colors, 0, 256);
-
+				break;
 			}
-
-			break;
-
 			case SET_DECODING_MAP:
-
-				/* kill previous map */
-				free (map);
-
+			{
 				/* get new map */
-				map = (Uint8*) malloc (sizeof (Uint8) * op.length);
-				assert (map != NULL);
-				SDL_RWread (mve, map, op.length, 1);
+				map.resize (op.length);
+				SDL_RWread (mve, map.data(), op.length, 1);
 				break;
-
+			}
 			case VIDEO_DATA:
-
-				/* free the previously allocated video data array */
-				free (video);
-
+			{
 				/* allocate enough memory for the video data array */
-				video = (Uint8*) malloc (op.length);
-				assert (video != NULL);
+				video.resize (op.length);
 
-				/* swap the frames so we draw next on the frame that was onscreen 1 frame ago */
-				temp = frame_cold;
-				frame_cold = frame_hot;
-				frame_hot = temp;
+				// swap the frames so we draw next on the frame
+				// that was onscreen 1 frame ago */
+				std::swap (frame_cold, frame_hot);
 
 				/* read the data */
-				SDL_RWread (mve, video, op.length, 1);
+				SDL_RWread (mve, video.data(), op.length, 1);
 
 				/* decode the video data and update the frame_hot pixel data */
-				MVEPlayerDecodeVideo (width_blocks, height_blocks, video, map);
+				MVEPlayerDecodeVideo (width_blocks, height_blocks, video.data(), map.data());
 
 				break;
-
+			}
 			default:
-
+			{
 				/* are opcode parameters within known bounds? */
 				if (op.type > 0x15 || op.version > 3)
 					return MVE_CORRUPT;
@@ -601,6 +595,7 @@
 				mve->seek (mve, op.length, SEEK_CUR);
 
 				break;
+			}
 		}
 
 		/************************/
@@ -610,7 +605,6 @@
 		/* read opcode (trailing read) */
 		if (!SDL_RWread (mve, &op, sizeof (op), 1))
 			return OPCODE_READ_FAILED;
-
 	}
 	/***********/
 	/* cleanup */
@@ -624,37 +618,16 @@
 			SDL_PauseAudio (1);
 			SDL_CloseAudio();
 		}
-
-		/* free audio mvebuffers */
-		free (audio_mvebuffer.data);
-
-		free (audio_data_read.data);
-
-		free (temp_audio_mvebuffer.data);
-
-		/* free the audio_spec */
-		free (desired);
 	}
 
-	/* free the decoding map */
-	free (map);
-
-	/* free the video data */
-	free (video);
-
-	/* free the video mvebuffers */
-	free (v_backbuf);
-
-	if (screen)
-		SDL_FreeSurface (screen);
-
 	/* close the file handle */
 	if (mve)
 		SDL_RWclose (mve);
 
 	/* reset video mode to original */
-	if (!fullscreen)
-		SDL_SetVideoMode (initial_vid_state->current_w, initial_vid_state->current_h, initial_vid_state->vfmt->BitsPerPixel, SDL_ANYFORMAT);
+	if (sdlTexture) SDL_DestroyTexture (sdlTexture);
+	if (sdlRenderer) SDL_DestroyRenderer (sdlRenderer);
+	if (sdlWindow) SDL_DestroyWindow (sdlWindow);
 
 	/* seems to have worked. */
 	return SUCCESS;
@@ -666,41 +639,11 @@
 
 void MVEPlayerAudioCB (void* userdata, Uint8* stream, int len)
 {
-	Uint8* temp;
 	mvebuffer* audio_mvebuffer = reinterpret_cast<mvebuffer*> (userdata);
 
-	if ( (Uint32) len > audio_mvebuffer->length)
-	{
-		/* give SDL what we have */
-		memcpy (stream, audio_mvebuffer->data, audio_mvebuffer->length);
-		/* and now we have nothing */
-		audio_mvebuffer->length = 0;
-	}
-	else
-	{
-		/* copy len bytes to stream */
-		memcpy (stream, audio_mvebuffer->data, len);
-
-		/* our mvebuffer length is now whatever we started with minus len */
-		audio_mvebuffer->length -= len;
-
-		/* now we need to store the data that wasn't read */
-		temp = (Uint8*) malloc (audio_mvebuffer->length);
-		assert (temp != NULL);
-
-		/* copy from data address + len length bytes
-		(which should be the start of the data that wasn't copied to stream) */
-		memcpy (temp, audio_mvebuffer->data + len, audio_mvebuffer->length);
-
-		/* free the memory of the audio_mvebuffer */
-		free (audio_mvebuffer->data);
-
-		/* assign the address of our stored data to the audio_mvebuffer's data */
-		audio_mvebuffer->data = temp;
-
-		/* close off temp */
-		temp = NULL;
-	}
+	len = std::min<size_t>(len, audio_mvebuffer->data.size());
+	std::copy(audio_mvebuffer->data.begin(), audio_mvebuffer->data.begin() + len, stream);
+	audio_mvebuffer->data.erase(audio_mvebuffer->data.begin(), audio_mvebuffer->data.begin() + len);
 }
 
 /* Interplay DPCM table */
@@ -732,43 +675,40 @@
 	/* this only works for stereo dpcm at present */
 
 	Sint16 sample[2];
-	Uint16 in_pos = 0, out_pos = 0;
+	Uint16 in_pos = 0;
+	Uint16 out_pos = 0;
 	Uint8 channel = 0;
 	mvebuffer out;
 
 	/* in->data includes initial stream-len word */
 	/* uncompressed streamlen is stream-len bytes */
-	out.length = LE16 (in->data);
+	out.data.resize (LE16 (in->data.data()));
 	in_pos += 2;
-	out.data = (Uint8*) malloc (out.length);
-	assert (out.data != NULL);
 
-	/* each byte in the input mvebuffer after the first four (two words: initial L and R values)
-	will be expanded to fill a word in the return mvebuffer after decompression.
-	The initial two words will be stored in return mvebuffer as-is. */
-	sample[0] = LE16 (in->data + in_pos);
+	// each byte in the input mvebuffer after the first four
+	// (two words: initial L and R values)
+	// will be expanded to fill a word
+	// in the return mvebuffer after decompression.
+	// The initial two words will be stored in return mvebuffer as-is.
+	sample[0] = LE16 (in->data.data() + in_pos);
 	in_pos += 2;
-	* (Sint16*) (out.data + out_pos) = sample[0];
+	* (Sint16*) (out.data.data() + out_pos) = sample[0];
 	out_pos += 2;
-	sample[1] = LE16 (in->data + in_pos);
+	sample[1] = LE16 (in->data.data() + in_pos);
 	in_pos += 2;
-	* (Sint16*) (out.data + out_pos) = sample[1];
+	* (Sint16*) (out.data.data() + out_pos) = sample[1];
 	out_pos += 2;
 
-	while (in_pos < in->length)
+	while (in_pos < in->data.size())
 	{
-		sample[channel] += interplay_delta_table[* (in->data + in_pos++)];
-		* (Sint16*) (out.data + out_pos) = sample[channel];
+		sample[channel] += interplay_delta_table[* (in->data.data() + in_pos++)];
+		* (Sint16*) (out.data.data() + out_pos) = sample[channel];
 		out_pos += 2;
 		channel = !channel;
 	}
 
-	/* free the original mvebuffer*/
-	free (in->data);
-
 	/* assign the incoming mvebuffer the outgoing data for return */
-	in->data = out.data;
-	in->length = out.length;
+	std::swap(in->data, out.data);
 }
 
 /**************************************/
@@ -776,40 +716,46 @@
 /**************************************/
 void MVEPlayerDecodeVideo (Uint16 wblocks, Uint16 hblocks, Uint8* pData, Uint8* pMap)
 {
-	Uint8 encoding = 0, *map = NULL, *data = NULL, *new_frame = NULL, *current = NULL, *temp = NULL;
-	Uint16 pitch = 0;
-	Sint32 x, y, i, j;
+	Uint8 encoding = 0, *new_frame = NULL, *current = NULL, *temp = NULL;
+	Uint8* map = pMap;
 
-	map = pMap;
-
 	/* there are 14 undocumented bytes at head of video stream */
-	data = pData + 14;
+	Uint8* data = pData + 14;
 
-	pitch = wblocks << 3;
+	Uint16 pitch = wblocks << 3;
 
 	/* for each row (of 8x8 pixel blocks) */
-	for (y = 0; y < hblocks; y++)
+	for (Sint16 y = 0; y < hblocks; y++)
 	{
 		/* for each column (of 8x8 pixel blocks) */
-		for (x = 0; x < wblocks; x++)
+		for (Sint16 x = 0; x < wblocks; x++)
 		{
-			/* assign the frame mvebuffer pointers to the addresses of the screen
-			mvebuffers so we can do pointer arithmetic on them such as incrementing.
-			current is the frame currently onscreen; new_frame is the frame under construction. */
+			// assign the frame mvebuffer pointers
+			// to the addresses of the screen
+			// mvebuffers so we can do pointer arithmetic on them
+			// such as incrementing.
+			// current is the frame currently onscreen;
+			// new_frame is the frame under construction.
 
 			new_frame = frame_hot;
 			current = frame_cold;
 
-			/* increment pixel pointer past the rendered area on the screen
-			y = number of rows, wblocks = number of blocks per row, 8 * 8 = pixel area of the block;
-			y * wblocks * 8 * 8 = all the complete rows of 8x8 pixel blocks rendered.
-			x * 8 = upper left pixel of the 8x8 block in this new row to be rendered at this time.
-			I felt like replacing the multiplications throughout this function with shift operations. */
+			// increment pixel pointer past the rendered area on the screen
+			// y = number of rows,
+			// wblocks = number of blocks per row,
+			// 8 * 8 = pixel area of the block;
+			// y * wblocks * 8 * 8 = all the complete rows
+			//  of 8x8 pixel blocks rendered.
+			// x * 8 = upper left pixel of the 8x8 block
+			// in this new row to be rendered at this time.
+			// I felt like replacing the multiplications
+			// throughout this function with shift operations.
 
 			new_frame += (y * wblocks << 6) + (x << 3);
 			current += (y * wblocks << 6) + (x << 3);
 
-			/* get the decoding map info for this block; low 4 bits if x is even, high 4 bits if x is odd */
+			// get the decoding map info for this block;
+			// low 4 bits if x is even, high 4 bits if x is odd
 			encoding = (*map >> ( (x & 1) << 2)) & 0x0f;
 
 			/* if x is odd, increment the decoding map */
@@ -820,7 +766,7 @@
 			{
 				case 0x0:
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memcpy (new_frame + j * pitch, current + j * pitch, 8);
 					}
@@ -832,6 +778,8 @@
 					break;
 
 				case 0x2:
+				{
+					Sint32 i, j;
 
 					temp = new_frame;
 					if (*data < 56)
@@ -848,15 +796,16 @@
 
 					temp += j * pitch + i;
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memcpy (new_frame + j * pitch, temp + j * pitch, 8);
 					}
 
 					break;
-
+				}
 				case 0x3:
-
+				{
+					Sint32 i, j;
 					temp = new_frame;
 					if (*data < 56)
 					{
@@ -872,40 +821,40 @@
 
 					temp += j * pitch + i;
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memcpy (new_frame + j * pitch, temp + j * pitch, 8);
 					}
 
 					break;
-
+				}
 				case 0x4:
-
-					i = -8 + (*data & 0xF);
-					j = -8 + (*data >> 4);
+				{
+					Sint32 i = -8 + (*data & 0xF);
+					Sint32 j = -8 + (*data >> 4);
 					data++;
 
 					current += j * pitch + i;
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memcpy (new_frame + j * pitch, current + j * pitch, 8);
 					}
 
 					break;
-
+				}
 				case 0x5:
-
+				{
 					current += (Sint8) data[1] * pitch + (Sint8) data[0];
 					data += 2;
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memcpy (new_frame + j * pitch, current + j * pitch, 8);
 					}
 
 					break;
-
+				}
 				case 0x6:
 
 					x += 2;
@@ -925,13 +874,13 @@
 
 					if (p[0] <= p[1])
 					{
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							b[i] = *data++;
 						}
-						for (j = 0; j < 8; j++)
+						for (int j = 0; j < 8; j++)
 						{
-							for (i = 0, mask = 1; i < 8; i++, mask <<= 1)
+							for (int i = 0, mask = 1; i < 8; i++, mask <<= 1)
 							{
 								new_frame[i] = p[!! (b[j] & mask)];
 							}
@@ -943,11 +892,11 @@
 						b[0] = *data++;
 						b[1] = *data++;
 
-						for (j = 0; j < 4; j++)
+						for (int j = 0; j < 4; j++)
 						{
 							if (! (j % 2))
 								mask = 0x01;
-							for (i = 0; i < 4; i++, mask <<= 1)
+							for (int i = 0; i < 4; i++, mask <<= 1)
 							{
 								new_frame[i << 1] =
 									new_frame[ (i << 1) + 1] =
@@ -963,22 +912,22 @@
 
 				case 0x8:
 				{
-					Uint8 p[8], b[8], mask = 1, k;
+					Uint8 p[8], b[8], mask = 1;
 					if (data[0] <= data[1])
 					{
-						for (j = 0; j < 4; j++)
+						for (int j = 0; j < 4; j++)
 						{
-							for (i = 0; i < 2; i++)
+							for (int i = 0; i < 2; i++)
 							{
 								p[i + (j << 1)] = *data++;
 							}
-							for (i = 0; i < 2; i++)
+							for (int i = 0; i < 2; i++)
 							{
 								b[i + (j << 1)] = *data++;
 							}
 						}
 
-						for (k = 0; k < 4; k++)
+						for (int k = 0; k < 4; k++)
 						{
 							if (k == 2)
 							{
@@ -985,11 +934,11 @@
 								new_frame -= pitch << 3;
 								new_frame += 4;
 							}
-							for (j = 0; j < 4; j++)
+							for (int j = 0; j < 4; j++)
 							{
 								if (! (j & 1))
 									mask = 1;
-								for (i = 0; i < 4; i++)
+								for (int i = 0; i < 4; i++)
 								{
 									new_frame[i] = p[!! (b[ (j >> 1) + (k << 1)] & mask) + (k << 1)];
 									mask <<= 1;
@@ -1000,13 +949,13 @@
 					} /* if p0 <= p1 */
 					else
 					{
-						for (j = 0; j < 2; j++)
+						for (int j = 0; j < 2; j++)
 						{
-							for (i = 0; i < 2; i++)
+							for (int i = 0; i < 2; i++)
 							{
 								p[ (j << 1) + i] = *data++;
 							}
-							for (i = 0; i < 4; i++)
+							for (int i = 0; i < 4; i++)
 							{
 								b[ (j << 2) + i] = *data++;
 							}
@@ -1014,9 +963,9 @@
 						if (p[2] > p[3])
 						{
 							/* horizontally split block */
-							for (j = 0; j < 8; j++)
+							for (int j = 0; j < 8; j++)
 							{
-								for (i = 0, mask = 1; i < 8; i++, mask <<= 1)
+								for (int i = 0, mask = 1; i < 8; i++, mask <<= 1)
 								{
 									new_frame[i] = p[!! (b[j] & mask) + (j > 3 ? 2 : 0)];
 								}
@@ -1026,7 +975,7 @@
 						else
 						{
 							/* vertically split block */
-							for (k = 0; k < 2; k++)
+							for (int k = 0; k < 2; k++)
 							{
 								if (k == 1)
 								{
@@ -1033,10 +982,10 @@
 									new_frame -= pitch << 3;
 									new_frame += 4;
 								}
-								for (j = 0; j < 4; j++)
+								for (int j = 0; j < 4; j++)
 								{
 									mask = 1;
-									for (i = 0; i < 8; i++)
+									for (int i = 0; i < 8; i++)
 									{
 										new_frame[i % 4] = p[!! (b[j + (k << 2)] & mask) + (k << 1)];
 										mask <<= 1;
@@ -1055,20 +1004,20 @@
 				case 0x9:
 				{
 					Uint8 p[4], b[16];
-					for (i = 0; i < 4; i++)
+					for (int i = 0; i < 4; i++)
 					{
 						p[i] = *data++;
 					}
 					if (p[0] <= p[1] && p[2] <= p[3])
 					{
-						Uint16 mask;
-						for (i = 0; i < 16; i++)
+						for (int i = 0; i < 16; i++)
 						{
 							b[i] = *data++;
 						}
-						for (j = 0; j < 8; j++)
+						for (int j = 0; j < 8; j++)
 						{
-							for (i = 0, mask = 3; i < 8; i++, mask <<= 2)
+
+							for (Uint16 i = 0, mask = 3; i < 8; i++, mask <<= 2)
 							{
 								new_frame[i] = p[ (mask & (b[ (j << 1) + 1] << 8 | b[j << 1])) >> (i << 1)];
 							}
@@ -1078,14 +1027,14 @@
 					if (p[0] <= p[1] && p[2] > p[3])
 					{
 						Uint8 mask;
-						for (i = 0; i < 4; i++)
+						for (int i = 0; i < 4; i++)
 						{
 							b[i] = *data++;
 						}
-						for (j = 0; j < 8; j++)
+						for (int j = 0; j < 8; j++)
 						{
 							mask = 3;
-							for (i = 0; i < 8; i++)
+							for (int i = 0; i < 8; i++)
 							{
 								new_frame[i] = p[ (b[j >> 1] & mask) >> ( (i >> 1) << 1)];
 								if (i & 1)
@@ -1097,14 +1046,14 @@
 					if (p[0] > p[1] && p[2] <= p[3])
 					{
 						Uint8 mask;
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							b[i] = *data++;
 						}
-						for (j = 0; j < 8; j++)
+						for (int j = 0; j < 8; j++)
 						{
 							mask = 3;
-							for (i = 0; i < 8; i++)
+							for (int i = 0; i < 8; i++)
 							{
 								new_frame[i] = p[ (b[j] & mask) >> ( (i >> 1) << 1)];
 								if (i & 1)
@@ -1116,14 +1065,14 @@
 					if (p[0] > p[1] && p[2] > p[3])
 					{
 						Uint16 mask;
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							b[i] = *data++;
 						}
-						for (j = 0; j < 4; j++)
+						for (int j = 0; j < 4; j++)
 						{
 							mask = 3;
-							for (i = 0; i < 8; i++)
+							for (int i = 0; i < 8; i++)
 							{
 								new_frame[i] =
 									new_frame[i + pitch] = p[ ( (b[ (j << 1) + 1] << 8 | b[j << 1]) & mask) >> (i << 1)];
@@ -1138,25 +1087,25 @@
 
 				case 0xA:
 				{
-					Uint8 p[16], b[16], mask, k;
+					Uint8 p[16], b[16];
 					if (data[0] <= data[1])
 					{
-						for (i = 0; i < 4; i++)
+						for (int i = 0; i < 4; i++)
 						{
-							for (j = 0; j < 4; j++)
+							for (int j = 0; j < 4; j++)
 							{
 								p[ (i << 2) + j] = *data++;
 							}
-							for (j = 0; j < 4; j++)
+							for (int j = 0; j < 4; j++)
 							{
 								b[ (i << 2) + j] = *data++;
 							}
 						}
-						for (k = 0; k < 4; k++)
+						for (int k = 0; k < 4; k++)
 						{
-							for (j = 0; j < 4; j++)
+							for (int j = 0; j < 4; j++)
 							{
-								for (i = 0, mask = 3; i < 4; i++, mask <<= 2)
+								for (Uint8 i = 0, mask = 3; i < 4; i++, mask <<= 2)
 								{
 									new_frame[i] = p[ ( (b[ (k << 2) + j] & mask) >> (i << 1)) + (k << 2)];
 								}
@@ -1171,13 +1120,13 @@
 					}
 					else
 					{
-						for (i = 0; i < 2; i++)
+						for (int i = 0; i < 2; i++)
 						{
-							for (j = 0; j < 4; j++)
+							for (int j = 0; j < 4; j++)
 							{
 								p[ (i << 2) + j] = *data++;
 							}
-							for (j = 0; j < 8; j++)
+							for (int j = 0; j < 8; j++)
 							{
 								b[ (i << 3) + j] = *data++;
 							}
@@ -1184,11 +1133,11 @@
 						}
 						if (p[4] <= p[5])
 						{
-							for (k = 0; k < 2; k++)
+							for (int k = 0; k < 2; k++)
 							{
-								for (j = 0; j < 8; j++)
+								for (int j = 0; j < 8; j++)
 								{
-									for (i = 0, mask = 3; i < 4; i++, mask <<= 2)
+									for (int i = 0, mask = 3; i < 4; i++, mask <<= 2)
 									{
 										new_frame[i] = p[ ( (b[j + (k << 3)] & mask) >> (i << 1)) + (k << 2)];
 									}
@@ -1203,11 +1152,11 @@
 						}
 						else
 						{
-							for (k = 0; k < 2; k++)
+							for (int k = 0; k < 2; k++)
 							{
-								for (j = 0; j < 4; j++)
+								for (int j = 0; j < 4; j++)
 								{
-									for (i = 0, mask = 3; i < 8; i++, mask <<= 2)
+									for (int i = 0, mask = 3; i < 8; i++, mask <<= 2)
 									{
 										if (i == 4)
 											mask = 3;
@@ -1225,9 +1174,9 @@
 
 				case 0xB:
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							new_frame[i] = *data++;
 						}
@@ -1239,13 +1188,13 @@
 				case 0xC:
 				{
 					Uint8 p[16];
-					for (i = 0; i < 16; i++)
+					for (int i = 0; i < 16; i++)
 					{
 						p[i] = *data++;
 					}
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							new_frame[i] = p[ (i >> 1) + ( (j >> 1) << 2)];
 						}
@@ -1258,13 +1207,13 @@
 				case 0xD:
 				{
 					Uint8 p[4];
-					for (i = 0; i < 4; i++)
+					for (int i = 0; i < 4; i++)
 					{
 						p[i] = *data++;
 					}
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 						{
 							new_frame[i] = p[ ( (j > 3 ? 1 : 0) << 1) + (i > 3 ? 1 : 0)];
 						}
@@ -1276,7 +1225,7 @@
 
 				case 0xE:
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
 						memset (new_frame + j * pitch, *data, 8);
 					}
@@ -1286,9 +1235,9 @@
 
 				case 0xF:
 
-					for (j = 0; j < 8; j++)
+					for (int j = 0; j < 8; j++)
 					{
-						for (i = 0; i < 8; i++)
+						for (int i = 0; i < 8; i++)
 							new_frame[i] = data[ ( (i + j) & 1)];
 						new_frame += pitch;
 					}
@@ -1305,8 +1254,10 @@
 /*************************************/
 void MVEPlayerEventHandler()
 {
-	/* event vars for determining pause, quit, or speed commands from user; declared static
-	so they retain their values between calls to MVEPlayerEventHandler (else nothing happens) */
+	// event vars for determining pause, quit, or speed commands from user;
+	// declared static
+	// so they retain their values between calls to MVEPlayerEventHandler
+	// (else nothing happens)
 
 	static Uint8 keyin = 0;
 	static SDL_Event event;
@@ -1315,9 +1266,7 @@
 	{
 		switch (event.type)
 		{
-			case SDL_KEYDOWN:
-				keyin = event.key.keysym.sym;
-				break;
+			case SDL_KEYDOWN: keyin = event.key.keysym.sym; break;
 			case SDL_KEYUP:
 				if (event.key.keysym.sym == keyin)
 				{
@@ -1335,10 +1284,9 @@
 							else if (AUDIO_PLAYING)
 								SDL_PauseAudio (0);
 							break;
-							/* ToggleFullScreen does not work on my system so I cannot test it */
-							/*case SDLK_f:
-								SDL_WM_ToggleFullScreen(screen);
-								break;*/
+							// ToggleFullScreen does not work on my system
+							// so I cannot test it
+							//case SDLK_f: SDL_WM_ToggleFullScreen(screen); break;
 						default:
 							QUITTING = !QUITTING;
 							break;
Index: network.cpp
===================================================================
--- network.cpp	(revision 3442)
+++ network.cpp	(working copy)
@@ -88,7 +88,7 @@
 	bHost = false;
 
 	bExit = false;
-	TCPHandleThread = SDL_CreateThread (CallbackHandleNetworkThread, this);
+	TCPHandleThread = SDL_CreateThread (CallbackHandleNetworkThread, "network", this);
 }
 
 //------------------------------------------------------------------------
Index: pcx.cpp
===================================================================
--- pcx.cpp	(revision 3442)
+++ pcx.cpp	(working copy)
@@ -109,7 +109,7 @@
 	if (!FileExists (name.c_str()))
 	{
 		// File not found, create empty surface.
-		SDL_Surface* const s = SDL_CreateRGBSurface (Video.getSurfaceType(), 100, 20, Video.getColDepth(), 0, 0, 0, 0);
+		SDL_Surface* const s = SDL_CreateRGBSurface (0, 100, 20, Video.getColDepth(), 0, 0, 0, 0);
 		return s;
 	}
 
@@ -117,7 +117,7 @@
 	if (!bufferedFile.open (name.c_str(), "rb"))
 	{
 		Log.write (SDL_GetError(), cLog::eLOG_TYPE_WARNING);  // Image corrupted, create empty surface.
-		SDL_Surface* const s = SDL_CreateRGBSurface (Video.getSurfaceType(), 100, 20, Video.getColDepth(), 0, 0, 0, 0);
+		SDL_Surface* const s = SDL_CreateRGBSurface (0, 100, 20, Video.getColDepth(), 0, 0, 0, 0);
 		return s;
 	}
 	// Load the image.
@@ -124,13 +124,13 @@
 	bufferedFile.seek (8, SEEK_SET);
 	Uint16       const x = bufferedFile.readLE16() + 1;
 	Uint16       const y = bufferedFile.readLE16() + 1;
-	SDL_Surface* const s = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, x, y, 32, 0, 0, 0, 0);
+	SDL_Surface* const s = SDL_CreateRGBSurface (0, x, y, 32, 0, 0, 0, 0);
 	if (!s)
 	{
 		Log.write (SDL_GetError(), cLog::eLOG_TYPE_ERROR);
 		return NULL; //app will crash using this
 	}
-	SDL_SetColorKey (s, SDL_SRCCOLORKEY, 0xFF00FF);
+	SDL_SetColorKey (s, SDL_TRUE, 0xFF00FF);
 
 	Uint32* const buf = static_cast<Uint32*> (s->pixels);
 	bufferedFile.seek (128, RW_SEEK_SET);
Index: SDL_flic.c
===================================================================
--- SDL_flic.c	(revision 3442)
+++ SDL_flic.c	(working copy)
@@ -28,9 +28,9 @@
              added function FLI_Version that returns the library version
 */
 #include "SDL_flic.h"
+#include <string.h>
 #include <setjmp.h>
 #include <stdlib.h>
-//#include <mem.h>
 
 /* Library version. */
 #define FLI_MAJOR 1
@@ -46,6 +46,14 @@
 #define FLI_COPY     16
 #define FLI_PSTAMP   18
 
+#if 1 // TODO: [SDL2]: SDL_SetColors
+inline void SDL_SetColors (SDL_Surface* surface, SDL_Color* colors, int index, int size)
+{
+	SDL_SetPaletteColors (surface->format->palette, colors, index, size);
+}
+#endif
+
+
 typedef struct {
         Uint32 size, type, numchunks;
 } FLI_Frame;
@@ -54,7 +62,7 @@
         Uint32 size, type, index;
 } FLI_Chunk;
 
-static void readbuffer(FLI_Animation *flic, void *buffer, int size) {
+static void readbuffer(FLI_Animation *flic, void *buffer, unsigned int size) {
         if (SDL_RWread(flic->rwops, buffer, 1, size) != size)
                 longjmp(flic->error, FLI_READERROR);
 }
@@ -97,7 +105,7 @@
 
 static void readheader(FLI_Animation *flic) {
         /* Skip size, we don't need it. */
-        SDL_RWseek(flic->rwops, 4, SEEK_CUR);
+        SDL_RWseek(flic->rwops, 4, RW_SEEK_CUR);
         /* Read and check magic. */
         flic->format = readu16(flic);
         if (flic->format != FLI_FLI && flic->format != FLI_FLC)
@@ -120,7 +128,7 @@
         /* Read the delay between frames. */
         flic->delay = (flic->format == FLI_FLI) ? readu16(flic) : readu32(flic);
         /* Skip rest of the header. */
-        SDL_RWseek(flic->rwops, (flic->format == FLI_FLI) ? 110 : 108, SEEK_CUR);
+        SDL_RWseek(flic->rwops, (flic->format == FLI_FLI) ? 110 : 108, RW_SEEK_CUR);
 }
 
 static void readframe(FLI_Animation *flic, FLI_Frame *frame) {
@@ -135,7 +143,7 @@
         /* Read the number of chunks in this frame. */
         frame->numchunks = readu16(flic);
         /* Skip rest of the data. */
-        SDL_RWseek(flic->rwops, 8, SEEK_CUR);
+        SDL_RWseek(flic->rwops, 8, RW_SEEK_CUR);
 }
 
 static void readchunk(FLI_Animation *flic, FLI_Chunk *chunk) {
@@ -357,7 +365,7 @@
         readframe(flic, &frame);
         /* If it's a prefix frame, skip it. */
         if (frame.type == 0xF100) {
-                SDL_RWseek(rwops, frame.size - 16, SEEK_CUR);
+                SDL_RWseek(rwops, frame.size - 16, RW_SEEK_CUR);
                 flic->offframe1 = SDL_RWtell(rwops);
                 flic->numframes--;
         }
@@ -393,7 +401,7 @@
                 return error;
         }
         /* Seek to the current frame. */
-        SDL_RWseek(flic->rwops, flic->offnextframe, SEEK_SET);
+        SDL_RWseek(flic->rwops, flic->offnextframe, RW_SEEK_SET);
         /* Read the current frame. */
         readframe(flic, &frame);
         /* Read and process each of the chunks of this frame. */
@@ -426,7 +434,7 @@
                                 break;
                         case FLI_PSTAMP:
                                 /* Ignore this chunk. */
-								SDL_RWseek( flic->rwops, chunk.size - 6, SEEK_CUR );
+								SDL_RWseek( flic->rwops, chunk.size - 6, RW_SEEK_CUR );
                                 break;
                         default:
                                 longjmp(flic->error, FLI_CORRUPTEDFILE);
@@ -457,7 +465,7 @@
         if (error != 0)
                 return error;
         /* Seek to the current frame. */
-        SDL_RWseek(flic->rwops, flic->offnextframe, SEEK_SET);
+        SDL_RWseek(flic->rwops, flic->offnextframe, RW_SEEK_SET);
         /* Read the current frame. */
         readframe(flic, &frame);
         /* Skip to the next frame without rendering. */
Index: server.cpp
===================================================================
--- server.cpp	(revision 3449)
+++ server.cpp	(working copy)
@@ -20,24 +20,6 @@
 #include <cassert>
 #include <set>
 
-#ifdef _MSC_VER
-
-# define NOMINMAX // do not use min, max as macro
-# include <windows.h>
-const DWORD MS_VC_EXCEPTION = 0x406D1388;
-
-# pragma pack (push, 8)
-typedef struct tagTHREADNAME_INFO
-{
-	DWORD dwType; // Must be 0x1000.
-	LPCSTR szName; // Pointer to name (in user addr space).
-	DWORD dwThreadID; // Thread ID (-1=caller thread).
-	DWORD dwFlags; // Reserved for future use, must be zero.
-} THREADNAME_INFO;
-# pragma pack (pop)
-#endif
-
-
 #include "server.h"
 
 #include "attackJobs.h"
@@ -71,22 +53,6 @@
 //------------------------------------------------------------------------------
 int CallbackRunServerThread (void* arg)
 {
-#if defined _MSC_VER && defined DEBUG //set a readable thread name for debugging
-	THREADNAME_INFO info;
-	info.dwType = 0x1000;
-	info.szName = "Server Thread";
-	info.dwThreadID = -1;
-	info.dwFlags = 0;
-
-	__try
-	{
-		RaiseException (MS_VC_EXCEPTION, 0, sizeof (info) / sizeof (ULONG_PTR), reinterpret_cast<ULONG_PTR*> (&info));
-	}
-	__except (EXCEPTION_EXECUTE_HANDLER)
-	{
-	}
-#endif
-
 	cServer* server = reinterpret_cast<cServer*> (arg);
 	server->run();
 	return 0;
@@ -116,7 +82,7 @@
 	if (!DEDICATED_SERVER)
 	{
 		if (network) network->setMessageReceiver (this);
-		serverThread = SDL_CreateThread (CallbackRunServerThread, this);
+		serverThread = SDL_CreateThread (CallbackRunServerThread, "server", this);
 	}
 
 	gameTimer.maxEventQueueSize = MAX_SERVER_EVENT_COUNTER;
Index: servergame.cpp
===================================================================
--- servergame.cpp	(revision 3447)
+++ servergame.cpp	(working copy)
@@ -70,7 +70,7 @@
 //------------------------------------------------------------------------------
 void cServerGame::runInThread()
 {
-	thread = SDL_CreateThread (serverGameThreadFunction, this);
+	thread = SDL_CreateThread (serverGameThreadFunction, "servergame", this);
 }
 
 //------------------------------------------------------------------------------
Index: unifonts.cpp
===================================================================
--- unifonts.cpp	(revision 3442)
+++ unifonts.cpp	(working copy)
@@ -148,21 +148,21 @@
 				else if (charset == CHARSET_ISO8559_1) unicodeplace = currentChar + 128 + 2 * 16;
 			}
 			else unicodeplace = iso8859_to_uni[currentChar];
-			chars[unicodeplace] = SDL_CreateRGBSurface (Video.getSurfaceType() | SDL_SRCCOLORKEY, Rect.w, Rect.h, 32, 0, 0, 0, 0);
+			chars[unicodeplace] = SDL_CreateRGBSurface (0, Rect.w, Rect.h, 32, 0, 0, 0, 0);
 
 			// change color of smal fonts
 			switch (fonttype)
 			{
 				case FONT_LATIN_SMALL_RED:
-					SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xf0d8b8);
+					SDL_SetColorKey (surface, SDL_TRUE, 0xf0d8b8);
 					SDL_FillRect (chars[unicodeplace], NULL, 0xe60000);
 					break;
 				case FONT_LATIN_SMALL_GREEN:
-					SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xf0d8b8);
+					SDL_SetColorKey (surface, SDL_TRUE, 0xf0d8b8);
 					SDL_FillRect (chars[unicodeplace], NULL, 0x04ae04);
 					break;
 				case FONT_LATIN_SMALL_YELLOW:
-					SDL_SetColorKey (surface, SDL_SRCCOLORKEY, 0xf0d8b8);
+					SDL_SetColorKey (surface, SDL_TRUE, 0xf0d8b8);
 					SDL_FillRect (chars[unicodeplace], NULL, 0xdbde00);
 					break;
 				default:
@@ -170,7 +170,7 @@
 					break;
 			}
 			SDL_BlitSurface (surface, &Rect, chars[unicodeplace], NULL);
-			SDL_SetColorKey (chars[unicodeplace], SDL_SRCCOLORKEY, 0xFF00FF);
+			SDL_SetColorKey (chars[unicodeplace], SDL_TRUE, 0xFF00FF);
 
 			//goto next character
 			currentChar++;
Index: vehicles.cpp
===================================================================
--- vehicles.cpp	(revision 3442)
+++ vehicles.cpp	(working copy)
@@ -216,12 +216,12 @@
 		}
 	}
 
-	if (IsBuilding && !job && BigBetonAlpha < 255u)
+	if (IsBuilding && !job && BigBetonAlpha < 254u)
 	{
 		if (gameGUI.timer50ms)
 			BigBetonAlpha += 25;
 
-		BigBetonAlpha = std::min (255u, BigBetonAlpha);
+		BigBetonAlpha = std::min (254u, BigBetonAlpha);
 	}
 
 	// calculate screen position
@@ -287,7 +287,7 @@
 	// draw indication, when building is complete
 	if (IsBuilding && BuildRounds == 0 && owner == gameGUI.getClient()->getActivePlayer() && !BuildPath)
 	{
-		const Uint32 color = 0xFF00 - (0x1000 * (gameGUI.getAnimationSpeed() % 0x8));
+		const Uint32 color = 0xFF00FF00 - (0x1000 * (gameGUI.getAnimationSpeed() % 0x8));
 		const Uint16 max = data.isBig ? 2 * gameGUI.getTileSize() - 3 : gameGUI.getTileSize() - 3;
 		SDL_Rect d = {Sint16 (screenPosition.x + 2), Sint16 (screenPosition.y + 2), max, max};
 
@@ -297,7 +297,7 @@
 	// Draw the colored frame if necessary
 	if (gameGUI.colorChecked())
 	{
-		const Uint32 color = *static_cast<Uint32*> (owner->getColorSurface()->pixels);
+		const Uint32 color = 0xFF000000 | *static_cast<Uint32*> (owner->getColorSurface()->pixels);
 		const Uint16 max = data.isBig ? 2 * gameGUI.getTileSize() - 1 : gameGUI.getTileSize() - 1;
 
 		SDL_Rect d = {Sint16 (screenPosition.x + 1), Sint16 (screenPosition.y + 1), max, max};
@@ -307,7 +307,7 @@
 	// draw the group selected frame if necessary
 	if (groupSelected)
 	{
-		const Uint32 color = 0x00FFFF00;
+		const Uint32 color = 0xFFFFFF00;
 		const Uint16 tilesize = gameGUI.getTileSize() - 3;
 		SDL_Rect d = {Sint16 (screenPosition.x + 2), Sint16 (screenPosition.y + 2), tilesize, tilesize};
 
@@ -320,7 +320,7 @@
 		const int len = max / 4;
 		max -= 3;
 		SDL_Rect d = {Sint16 (screenPosition.x + 2), Sint16 (screenPosition.y + 2), max, max};
-		DrawSelectionCorner(buffer, d, len, gameGUI.getBlinkColor());
+		DrawSelectionCorner(buffer, d, len, 0xFF000000 | gameGUI.getBlinkColor());
 	}
 
 	// draw health bar
@@ -360,7 +360,7 @@
 	tmp.x += offset;
 	tmp.y += offset;
 
-	SDL_SetAlpha (uiData->overlay, SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (uiData->overlay, alpha);
 	blitWithPreScale (uiData->overlay_org, uiData->overlay, &src, surface, &tmp, zoomFactor);
 }
 
@@ -374,7 +374,7 @@
 		frameNr = client->getGameGUI().getAnimationSpeed() % (uiData->overlay_org->w / uiData->overlay_org->h);
 	}
 
-	int alpha = 255;
+	int alpha = 254;
 	if (StartUp && cSettings::getInstance().isAlphaEffects())
 		alpha = StartUp;
 	drawOverlayAnimation (surface, dest, zoomFactor, frameNr, alpha);
@@ -388,7 +388,7 @@
 	const cMap& map = *client.getMap();
 	if (IsBuilding && data.isBig && (!map.isWaterOrCoast (PosX, PosY) || map.fields[map.getOffset (PosX, PosY)].getBaseBuilding()))
 	{
-		SDL_SetAlpha (GraphicsData.gfx_big_beton, SDL_SRCALPHA, BigBetonAlpha);
+		SDL_SetSurfaceAlphaMod (GraphicsData.gfx_big_beton, BigBetonAlpha);
 		CHECK_SCALING (GraphicsData.gfx_big_beton, GraphicsData.gfx_big_beton_org, zoomFactor);
 		SDL_BlitSurface (GraphicsData.gfx_big_beton, NULL, surface, &tmp);
 	}
@@ -409,7 +409,7 @@
 	src.x = 0;
 	src.y = 0;
 	tmp = dest;
-	SDL_SetAlpha (GraphicsData.gfx_tmp, SDL_SRCALPHA, 255);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_tmp, 254);
 	SDL_BlitSurface (GraphicsData.gfx_tmp, &src, surface, &tmp);
 }
 
@@ -434,7 +434,7 @@
 	src.x = 0;
 	src.y = 0;
 	tmp = dest;
-	SDL_SetAlpha (GraphicsData.gfx_tmp, SDL_SRCALPHA, 255);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_tmp, 254);
 	SDL_BlitSurface (GraphicsData.gfx_tmp, &src, surface, &tmp);
 }
 
@@ -442,8 +442,8 @@
 {
 	if (client.getMap()->isWater (PosX, PosY) && (data.isStealthOn & TERRAIN_SEA)) return;
 
-	if (StartUp && cSettings::getInstance().isAlphaEffects()) SDL_SetAlpha (uiData->shw[dir], SDL_SRCALPHA, StartUp / 5);
-	else SDL_SetAlpha (uiData->shw[dir], SDL_SRCALPHA, 50);
+	if (StartUp && cSettings::getInstance().isAlphaEffects()) SDL_SetSurfaceAlphaMod (uiData->shw[dir], StartUp / 5);
+	else SDL_SetSurfaceAlphaMod (uiData->shw[dir], 50);
 	SDL_Rect tmp = dest;
 
 	// draw shadow
@@ -491,7 +491,7 @@
 	src.y = 0;
 	SDL_Rect tmp = dest;
 
-	SDL_SetAlpha (GraphicsData.gfx_tmp, SDL_SRCALPHA, alpha);
+	SDL_SetSurfaceAlphaMod (GraphicsData.gfx_tmp, alpha);
 	blittAlphaSurface (GraphicsData.gfx_tmp, &src, surface, &tmp);
 }
 
@@ -523,7 +523,7 @@
 		render_shadow (*client, surface, dest, zoomFactor);
 	}
 
-	int alpha = 255;
+	int alpha = 254;
 	if (client)
 	{
 		if (StartUp && cSettings::getInstance().isAlphaEffects())
Index: vehicles.h
===================================================================
--- vehicles.h	(revision 3442)
+++ vehicles.h	(working copy)
@@ -281,13 +281,13 @@
 	* draws the main image of the vehicle onto the passed surface
 	*/
 	void render (const cClient* client, SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, bool drawShadow);
-	void render_simple (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int alpha = 255);
+	void render_simple (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int alpha = 254);
 	/**
 	* draws the overlay animation of the vehicle on the given surface
 	*@author: eiko
 	*/
 	void drawOverlayAnimation (const cClient* client, SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor);
-	void drawOverlayAnimation (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int frameNr, int alpha = 255);
+	void drawOverlayAnimation (SDL_Surface* surface, const SDL_Rect& dest, float zoomFactor, int frameNr, int alpha = 254);
 
 	bool isUnitLoaded() const { return Loaded; }
 	/**
Index: video.cpp
===================================================================
--- video.cpp	(revision 3450)
+++ video.cpp	(working copy)
@@ -23,57 +23,65 @@
 #include "autosurface.h"
 #include "defines.h"
 #include "log.h"
+#include "mouse.h"
 #include "pcx.h"
 
+#include <algorithm>
 #include <vector>
 
+#include <SDL.h>
+
+// TODO: [SDL2] move static into Video
+
+static SDL_Window* sdlWindow;
+static SDL_Renderer* sdlRenderer;
+static SDL_Texture* sdlTexture;
+
 cVideo Video;
 
-/**
-* Will store either our detected videomodes
-* or some generic video modes if auto-detection in doDetect() failed
-*/
-static std::vector<sVidMode> vVideoMode;
+/** Slashscreen width  */
+#define SPLASHWIDTH 500
+/** Slashscreen height  */
+#define SPLASHHEIGHT 420
+#define COLOURDEPTH 32
+/**Minimum video mode resultion we need */
+#define MINWIDTH 640
+#define MINHEIGHT 480
 
-/**
- * Some possible video modes. Don't use external!'
- */
-static const sVidMode videoModes[] =
+struct sVidMode
 {
-	{ MINWIDTH, MINHEIGHT, 0 },
-	{  800,  600,  1 },
-	{  960,  720,  2 },
-	{ 1024,  768,  3 },
-	{ 1024,  960,  4 },
-	{ 1152,  864,  5 },
-	{ 1280,  960,  6 },
-	{ 1280, 1024,  7 },
-	{ 1040, 1050,  8 },
-	{ 1600, 1200,  9 },
-	{ 2048, 1536, 10 }, // unusual resolutions start here
-	{ 1024,  480, 11 }, // Sony VAIO Pocketbook
-	{ 1152,  768, 12 }, // Apple TiBook
-	{ 1280,  854, 13 }, // Apple TiBook
-	{  640,  400, 14 }, // generic 16:10 widescreen
-	{  800,  500, 15 }, // as found modern
-	{ 1024,  640, 16 }, // notebooks
-	{ 1280,  800, 17 },
-	{ 1680, 1050, 18 },
-	{ 1920, 1200, 19 },
-	{ 1400, 1050, 20 }, // samsung x20
-	{ 1440,  900, 21 },
-	{ 1024,  600, 22 } // EEE PC
+	unsigned int width;
+	unsigned int height;
 };
 
+static bool operator < (const sVidMode& lhs, const sVidMode& rhs)
+{
+	if (lhs.width != rhs.width) return lhs.width < rhs.width;
+	return lhs.height < rhs.height;
+}
+
+static bool operator == (const sVidMode& lhs, const sVidMode& rhs)
+{
+	return lhs.width == rhs.width && lhs.height == rhs.height;
+}
+
+struct sVidData
+{
+	unsigned int width;
+	unsigned int height;
+	int iColDepth;
+	bool bWindowMode;
+};
+
 /**
-* Stores our actual video data
+* Will store detected videomodes
 */
-static sVidData videoData = { MINWIDTH, MINHEIGHT, 0, SDL_SWSURFACE, 32, false };
+static std::vector<sVidMode> vVideoMode;
 
 /**
-* cvar for centered splash on screen
+* Stores our actual video data
 */
-static char cVideoPos[] = "SDL_VIDEO_CENTERED=1";
+static sVidData videoData = { MINWIDTH, MINHEIGHT, 32, false };
 
 int cVideo::setResolution (int iWidth, int iHeight, bool bApply)
 {
@@ -118,16 +126,7 @@
 	}
 	else
 	{
-		const SDL_VideoInfo* vInfo = SDL_GetVideoInfo();
-		if (vInfo != NULL)
-		{
-			Uint8 uBpp = vInfo->vfmt->BitsPerPixel;
-
-			if (iDepth > (Uint32) uBpp)
-			{
-				Log.write ("cVideo: Desired bpp is higher than the display (" + iToStr (uBpp) + "bpp) has!", cLog::eLOG_TYPE_WARNING);
-			}
-		}
+		// TODO: [SDL2] : sanitycheck
 		videoData.iColDepth = iDepth;
 	}
 	return 0;
@@ -141,7 +140,7 @@
 int cVideo::setWindowMode (bool bWindowMode, bool bApply)
 {
 	videoData.bWindowMode = bWindowMode;
-	Log.write ("cVideo: Window mode settings changed to " + std::string (Video.getWindowMode() ? "windowmode" : "fullscreen"), cLog::eLOG_TYPE_DEBUG);
+	Log.write ("cVideo: Window mode settings changed to " + std::string (getWindowMode() ? "windowmode" : "fullscreen"), cLog::eLOG_TYPE_DEBUG);
 
 	if (bApply)
 	{
@@ -155,54 +154,43 @@
 	// TODO: add sanity check to redraw function
 	SDL_BlitSurface (buffer, NULL, screen, NULL);
 
-	if (getWindowMode())
-	{
-		SDL_UpdateRect (screen, 0, 0, 0, 0);
-	}
-	else
-	{
-		SDL_Flip (screen);
-	}
+	SDL_UpdateTexture(sdlTexture, NULL, screen->pixels, screen->pitch);
+	SDL_RenderClear(sdlRenderer);
+	SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, NULL);
+	SDL_RenderPresent(sdlRenderer);
 }
 
 int cVideo::applySettings()
 {
-	int oldX = MINWIDTH;
-	int oldY = MINHEIGHT;
-	int oldDepth = COLOURDEPTH;
-	Uint32 oldSurface = SDL_SWSURFACE;
-
-	if (screen != NULL)
-	{
-		oldX = screen->w;
-		oldY = screen->h;
-		oldDepth = screen->format->BitsPerPixel;
-		oldSurface = screen->flags;
-	}
-
 	Log.write ("cVideo: Applying new video settings", cLog::eLOG_TYPE_DEBUG);
-	screen = SDL_SetVideoMode (getResolutionX(), getResolutionY(), getColDepth(), getSurfaceType() | (getWindowMode() ? 0 : SDL_FULLSCREEN));
 
-	if (screen == NULL)
+	SDL_SetWindowBordered(sdlWindow, SDL_TRUE);
+	SDL_SetWindowSize (sdlWindow, getResolutionX(), getResolutionY());
+	// TODO: [SDL2]: manage window mode correctly
+	if (SDL_SetWindowFullscreen (sdlWindow, !getWindowMode()) == -1)
 	{
-		Log.write ("cVideo:  => Failed. Reverting!", cLog::eLOG_TYPE_ERROR);
-		Log.write (SDL_GetError(), cLog::eLOG_TYPE_ERROR);
-		setResolution (oldX, oldY, false);
-		setColDepth (oldDepth);
-		// TODO: Don't know how to reset fullscreen mode proper from old values
-		Log.write ("cVideo: TODO: Don't know how to reset fullscreen mode proper from old values.", cLog::eLOG_TYPE_WARNING);
-		screen = SDL_SetVideoMode (oldX, oldY, oldDepth, oldSurface);
-		draw();
+		videoData.width = screen->w;
+		videoData.height = screen->h;
+		SDL_SetWindowSize (sdlWindow, getResolutionX(), getResolutionY());
 		return -1;
 	}
-	else
-	{
-		if (buffer) SDL_FreeSurface (buffer);
-		buffer = SDL_CreateRGBSurface (getSurfaceType(), getResolutionX(), getResolutionY(), getColDepth(), 0, 0, 0, 0);
-	}
+
+	if (screen) SDL_FreeSurface (screen);
+	screen = SDL_CreateRGBSurface (0, getResolutionX(), getResolutionY(), getColDepth(),
+								   0, 0, 0, 0);
+								   //0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	SDL_RenderSetLogicalSize(sdlRenderer, getResolutionX(), getResolutionY());
+	if (buffer) SDL_FreeSurface (buffer);
+	buffer = SDL_CreateRGBSurface (0, getResolutionX(), getResolutionY(), getColDepth(),
+								   //0, 0, 0, 0);
+								   0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	if (sdlTexture) SDL_DestroyTexture (sdlTexture);
+	sdlTexture = SDL_CreateTexture(sdlRenderer,
+								   SDL_PIXELFORMAT_ARGB8888,
+								   SDL_TEXTUREACCESS_STREAMING,
+								   getResolutionX(), getResolutionY());
 	draw();
 	return 0;
-
 }
 
 void cVideo::clearBuffer()
@@ -215,22 +203,33 @@
  */
 void cVideo::initSplash()
 {
-	if (putenv (cVideoPos) != 0)  // set window to center of screen.
-	{
-		Log.write ("cVideo: Couldn't export SDL_VIDEO_CENTERED", cLog::eLOG_TYPE_WARNING);
-	}
+	AutoSurface splash (LoadPCX (SPLASH_BACKGROUND));
 
-	buffer = LoadPCX (SPLASH_BACKGROUND);
-	SDL_WM_SetIcon (AutoSurface (SDL_LoadBMP (MAXR_ICON)), NULL);
+	std::string sVersion = PACKAGE_NAME " " PACKAGE_VERSION " " PACKAGE_REV " ";
 
-	// BEGIN VERSION STRING
-	std::string sVersion = PACKAGE_NAME; sVersion += " ";
-	sVersion += PACKAGE_VERSION; sVersion += " ";
-	sVersion += PACKAGE_REV; sVersion += " ";
-	SDL_WM_SetCaption (sVersion.c_str(), 0);
-	// END VERSION STRING
+	sdlWindow = SDL_CreateWindow(sVersion.c_str(),
+								 SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
+								 getSplashW(), getSplashH(),
+								 SDL_WINDOW_BORDERLESS | SDL_WINDOW_OPENGL);
+	SDL_SetWindowIcon (sdlWindow, AutoSurface (SDL_LoadBMP (MAXR_ICON)));
+	SDL_SetWindowFullscreen (sdlWindow, !getWindowMode());
+	sdlRenderer = SDL_CreateRenderer(sdlWindow, -1, 0);
 
-	screen = SDL_SetVideoMode (getSplashW(), getSplashH(), getColDepth(), getSurfaceType() | SDL_NOFRAME);
+	screen = SDL_CreateRGBSurface(0, getSplashW(), getSplashH(), getColDepth(),
+								  0, 0, 0, 0);
+	buffer = SDL_CreateRGBSurface(0, getSplashW(), getSplashH(), getColDepth(),
+								  0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+
+	SDL_BlitSurface (splash, NULL, buffer, NULL);
+
+	sdlTexture = SDL_CreateTexture(sdlRenderer,
+								   SDL_PIXELFORMAT_ARGB8888,
+								   SDL_TEXTUREACCESS_STREAMING,
+								   getSplashW(), getSplashH());
+	// make the scaled rendering look smoother.
+	SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
+	SDL_RenderSetLogicalSize(sdlRenderer, getSplashW(), getSplashH());
+
 	draw();
 }
 
@@ -249,106 +248,38 @@
 	return videoData.height;
 }
 
-void cVideo::setSurfaceType (Uint32 iSurfaceType)
-{
-	// TODO: set all surfaces to new surface type
-	if (videoData.iSurfaceType != iSurfaceType)
-	{
-		Log.write ("cVideo: Surface type " + getSurfaceName (getSurfaceType()) + " overwritten with " + getSurfaceName (iSurfaceType), cLog::eLOG_TYPE_INFO);
-	}
-	videoData.iSurfaceType = iSurfaceType;
-}
-
-Uint32 cVideo::getSurfaceType() const
-{
-	return videoData.iSurfaceType;
-}
-
-int cVideo::getVideoNum() const
-{
-	return sizeof (videoModes) / sizeof (sVidMode);
-}
-
 std::string cVideo::getVideoMode (unsigned int iMode) const
 {
-	// if no valid mode is given we return minimal video mode
-	std::string sTmp = iToStr (getMinW()) + "x" + iToStr (getMinH());
-	bool bFound = false;
-
-	for (unsigned int i = 0; i < vVideoMode.size(); i++)
-	{
-		if (vVideoMode[i].mode == iMode)
-		{
-			sTmp = iToStr (vVideoMode[i].width) + "x" + iToStr (vVideoMode[i].height);
-			bFound = true;
-			break;
-		}
-	}
-
-	if (!bFound)
-	{
-		Log.write ("cVideo: Video mode " + iToStr (iMode) + " not found. Returning default video mode " + sTmp, cLog::eLOG_TYPE_WARNING);
-	}
-
-	return sTmp;
+	return iToStr (vVideoMode[iMode].width) + "x" + iToStr (vVideoMode[iMode].height);
 }
 
-bool cVideo::doDetection()
+void cVideo::doDetection()
 {
 	Log.write ("cVideo: Screen resolution detection started. Results may vary!", cLog::eLOG_TYPE_INFO);
 
-	const SDL_VideoInfo* vInfo = SDL_GetVideoInfo();
-	vVideoMode.clear();
-
-	// detect us some video modes. detection works in fullscreen only.
-	// we try HW and SW surfaces
-	SDL_Rect** rDetectedModes = SDL_ListModes (vInfo->vfmt, SDL_FULLSCREEN | getSurfaceType());
-
-	if (rDetectedModes == NULL)
+	const int displayIndex = sdlWindow ? SDL_GetWindowDisplayIndex (sdlWindow) : 0;
+	const unsigned int modeCount = SDL_GetNumDisplayModes(displayIndex);
+	/* Print and store detected modes */
+	for (unsigned int i = 0; i != modeCount; ++i)
 	{
-		// try SWSURFACE if HWSURFACE doesn't work and vice versa
-		switchSurface();
-		// try with SWSURFACE
-		rDetectedModes = SDL_ListModes (vInfo->vfmt, SDL_FULLSCREEN | getSurfaceType());
-		if (rDetectedModes == NULL)
-		{
-			Log.write ("cVideo: No video modes detected. Probably bad!", cLog::eLOG_TYPE_ERROR);
-			vVideoMode.resize (getVideoNum());
-			// write some default video modes
-			for (size_t i = 0; i != vVideoMode.size(); ++i)
-			{
-				Log.write ("cVideo: Offering default video mode " + iToStr (i) + " (" + getVideoMode (i) + ")", cLog::eLOG_TYPE_WARNING);
-				vVideoMode.at (i) = videoModes[i];
-			}
-			return false;
-		}
-		else
-		{
-			Log.write ("cVideo: Detected video modes with " + getSurfaceName (getSurfaceType()) + " and " + iToStr (vInfo->vfmt->BitsPerPixel) + " bpp", cLog::eLOG_TYPE_INFO);
-		}
-	}
-	else
-	{
-		Log.write ("cVideo: Detected video modes with " + getSurfaceName (getSurfaceType()) + " and " + iToStr (vInfo->vfmt->BitsPerPixel) + " bpp", cLog::eLOG_TYPE_INFO);
-	}
+		SDL_DisplayMode mode;
+		SDL_GetDisplayMode (displayIndex, i, &mode);
 
-	/* Print and store detected modes */
-	for (unsigned int i = 0; rDetectedModes[i]; ++i)
-	{
 		// write detected video modes
 		// (don't write modes *below* the minimum mode'
-		if (rDetectedModes[i]->w >= MINWIDTH && rDetectedModes[i]->h >= MINHEIGHT)
+		if (mode.w >= MINWIDTH && mode.h >= MINHEIGHT)
 		{
-			sVidMode tmp = {rDetectedModes[i]->w, rDetectedModes[i]->h, i};
+			const sVidMode tmp = { unsigned (mode.w), unsigned (mode.h) };
 			vVideoMode.push_back (tmp);
-			Log.write ("cVideo: Offering detected video mode " + iToStr (i) + " (" + iToStr (rDetectedModes[i]->w) + "x" + iToStr (rDetectedModes[i]->h) + ")", cLog::eLOG_TYPE_INFO);
 		}
 	}
-
-	// sanity check on minimal needed screen resolution that we need at last
-	bHaveMinMode();
-
-	return true;
+	std::sort (vVideoMode.begin(), vVideoMode.end());
+	vVideoMode.erase (std::unique (vVideoMode.begin(), vVideoMode.end()), vVideoMode.end());
+	for (size_t i = 0; i != vVideoMode.size(); ++i)
+	{
+		sVidMode& mode = vVideoMode[i];
+		Log.write ("cVideo: Offering detected video mode " + iToStr (i) + " (" + iToStr (mode.width) + "x" + iToStr (mode.height) + ")", cLog::eLOG_TYPE_INFO);
+	}
 }
 
 bool cVideo::bHaveMinMode() const
@@ -402,17 +333,3 @@
 {
 	return MINHEIGHT;
 }
-
-std::string cVideo::getSurfaceName (Uint32 iSurfaceType) const
-{
-	if (iSurfaceType == SDL_SWSURFACE) return "SDL_SWSURFACE";
-	else if (iSurfaceType == SDL_HWSURFACE) return "SDL_HWSURFACE";
-	else return "UNKNOWN";
-}
-
-void cVideo::switchSurface()
-{
-	if (getSurfaceType() == SDL_SWSURFACE) setSurfaceType (SDL_HWSURFACE);
-	else if (getSurfaceType() == SDL_HWSURFACE) setSurfaceType (SDL_SWSURFACE);
-	else Log.write ("cVideo: Can't' switch surface types. Unknown surface type " + iToStr (getSurfaceType()) + " detected.", cLog::eLOG_TYPE_ERROR);
-}
Index: video.h
===================================================================
--- video.h	(revision 3442)
+++ video.h	(working copy)
@@ -20,34 +20,17 @@
 #ifndef videoH
 #define videoH
 
-#include <SDL.h>
 #include <string>
 
+struct SDL_Surface;
 
 // Screenbuffers //////////////////////////////////////////////////////////////
 EX SDL_Surface* screen; // Der Bildschirm
 EX SDL_Surface* buffer; // Der Bildschirm-Buffer
 
-
-struct sVidMode
-{
-	unsigned int width;
-	unsigned int height;
-	unsigned int mode;
-};
-
-struct sVidData
-{
-	unsigned int width;
-	unsigned int height;
-	unsigned int mode;
-	Uint32 iSurfaceType;
-	int iColDepth;
-	bool bWindowMode;
-};
-
 /**
- * cVideo class. Stores videosettings (and can hopefully operate 'em too one day'):-)
+ * cVideo class.
+ * Stores videosettings (and can hopefully operate 'em too one day'):-)
  *
  * @author Bernd "beko" Kosmahl
  */
@@ -55,162 +38,125 @@
 {
 public:
 	/**
-	*Sets whether app should appear windowed or in fullscreen mode
-	*@param bWindowMode pass true if app should work in windowed mode<br>pass false it app should start in fullscreen
-	*@param bApply set to true if app should apply new windowMode too
-	*@return 0 on success
+	* Sets whether app should appear windowed or in fullscreen mode
+	* @param bWindowMode pass true if app should work in windowed mode
+	*                    pass false it app should start in fullscreen
+	* @param bApply set to true if app should apply new windowMode too
+	* @return 0 on success
 	*/
 	int setWindowMode (bool bWindowMode, bool bApply = false);
 
 	/**
-	*Get whether app should appear windowed or in fullscreen mode
-	*@return  true if app should work in windowed mode<br>false it app should start in fullscreen
+	* Get whether app should appear windowed or in fullscreen mode
+	* @return  true if app should work in windowed mode
+	*          false it app should start in fullscreen
 	*/
 	bool getWindowMode() const;
 
 	/**
-	*Set resolution/dimension of app window.
-	*@param iWidth desired window width
-	*@param iHeight desired window height
-	*@param bApply  set to true if app should apply new resolution too
-	*@return 0 on success
+	* Set resolution/dimension of app window.
+	* @param iWidth desired window width
+	* @param iHeight desired window height
+	* @param bApply  set to true if app should apply new resolution too
+	* @return 0 on success
 	*/
 	int setResolution (int iWidth, int iHeight, bool bApply = false);
 
 	/**
-	*@deprecated for compat only - will be removed!
-	*@return stored window width
+	* @deprecated for compat only - will be removed!
+	* @return stored window width
 	*/
 	int getResolutionX() const;
 
 	/**
-	*@deprecated for compat only - will be removed!
-	*@return stored window height
+	* @deprecated for compat only - will be removed!
+	* @return stored window height
 	*/
 	int getResolutionY() const;
 
 	/**
-	*Sets colordepth
-	*@param iDepth colordepth to set. e.g. 32 (bpp)
-	*@return 0 on success
+	* Sets colordepth
+	* @param iDepth colordepth to set. e.g. 32 (bpp)
+	* @return 0 on success
 	*/
 	int setColDepth (unsigned int iDepth);
 
 	/**
-	*Gets colordepth
-	@return colordepth
+	* Gets colordepth
+	* @return colordepth
 	*/
 	int getColDepth() const;
 
 	/**
-	*Sets SurfaceType
-	*@param iSurfaceType surfacetype to set. e.g. SDL_HWSURFACE
+	* @return Detected videomodes
 	*/
-	void setSurfaceType (Uint32 iSurfaceType);
-
-	/**
-	*Gets SurfaceType
-	@return surfacetype e.g. SDL_HWSURFACE
-	*/
-	Uint32 getSurfaceType() const;
-
-	/**
-	*@return Detected videomodes
-	*/
 	int getVideoSize() const;
 
 	/**
-	*@param iMode video mode num from video mode array
-	*@return Videomode as string widthxheight. If iMode is unknown minimal needed videomode will be returned.
+	* @param iMode video mode num from video mode array
+	* @return Videomode as string widthxheight.
+	*         If iMode is unknown minimal needed videomode will be returned.
 	*/
 	std::string getVideoMode (unsigned int iMode) const;
 
 	/**
-	*Try to autodetect avail video modes from SDL. Might fail.
-	*@return true on success
+	* Try to autodetect availavle video modes from SDL.
 	*/
-	bool doDetection();
+	void doDetection();
 
 	/**
-	*Check whether the provided mode is known to our video mode list
-	*@param width Screenwidth to look for
-	*@param height Screenheight to look for
-	*@return iMode or -1 on unknown mode
+	* Check whether the provided mode is known to our video mode list
+	* @param width Screenwidth to look for
+	* @param height Screenheight to look for
+	* @return iMode or -1 on unknown mode
 	*/
 	int validateMode (unsigned int iWidth, unsigned int iHeight) const;
 
 	/**
-	*@return Splash width
+	* @return Splash width
 	*/
 	int getSplashW() const;
 
 	/**
-	*@return Splash height
+	* @return Splash height
 	*/
 	int getSplashH() const;
 
 	/**
-	*@return Minimal needed screen resolution width
+	* @return Minimal needed screen resolution width
 	*/
 	int getMinW() const;
 
 	/**
-	*@return Minimal needed screen resolution height
+	* @return Minimal needed screen resolution height
 	*/
 	int getMinH() const;
 
 	/**
-	*Inits our buffers and draws the splashscreen
+	* Inits our buffers and draws the splashscreen
 	*/
 	void initSplash();
 
 	/**
-	*clears buffer (black)
+	* clears buffer (black)
 	*/
 	void clearBuffer();
 
 	/**
-	*Blits or updates buffer to screen depending on windowmode
+	* Blits or updates buffer to screen depending on windowmode
 	*/
 	void draw();
 
 private:
-
-	/** Slashscreen width  */
-#define SPLASHWIDTH 500
-	/** Slashscreen height  */
-#define SPLASHHEIGHT 420
-#define COLOURDEPTH 32
-	/**Minimum video mode resultion we need */
-#define MINWIDTH 640
-#define MINHEIGHT 480
 	/**
-	*@return Length of videomodes array
+	* Checks whether our minimal needed videomode has been autodetected
+	* @return true if mininal video mode looks valid
 	*/
-	int getVideoNum() const;
-
-	/**
-	* Just for readable log entries
-	*@param iSurfaceType surface type SDL_HWSURFACE or SDL_SWSURFACE
-	*@return Surface type as string e.g."SDL_HWSURFACE"
-	*/
-	std::string getSurfaceName (Uint32 iSurfaceType) const;
-
-	/**
-	*Switch SDL_HWSURFACE with SDL_SWSURFACE and vice versa
-	*/
-	void switchSurface();
-
-	/**
-	*Checks whether our minimal needed videomode has been autodetected
-	*@return true if mininal video mode looks valid
-	*/
 	bool bHaveMinMode() const;
 
 	/**
-	*Applys current video settings
-	*@param bNoFrame set to true to start without window frame (e.g. for splashscreen)
-	*@return 0 on success
+	* Applys current video settings
+	* @return 0 on success
 	*/
 	int applySettings();
 };
